{"version":3,"sources":["../src/module/external_helpers.ts"],"names":[],"mappings":";AACA,OAAO,EAAE,aAAa,EAAE,MAAM,GAAG,CAAC;AAGlC,aAAK,UAAU,GAAG,OAAO,GAAG,MAAM,GAAG,UAAU,GAAG,OAAO,CAAC;AAO1D,oBAAY,uBAAuB,GAAG,CAAC,QAAQ,EAAE,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;AAKnI,oBAAY,mBAAmB,GAAG,CAAC,MAAM,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,EAAE,MAAM,EAAE,OAAO,KAAK,aAAa,EAAE,CAAC;AAYnG,oBAAY,uBAAuB,GAAG,CAAC,WAAW,EAAE,aAAa,EAAE,EAAE,MAAM,EAAE,OAAO,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;AAY5G,oBAAY,0BAA0B,GAAG,CAAC,CAAC,EAAE,MAAM,EAAE,EAAE,CAAC,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;AAiBhH,oBAAY,YAAY,GAAG,CAAC,EAAE,EAAE,MAAM,EAAE,EAAE,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;AAe9E,oBAAY,iBAAiB,GAAG,CAAC,UAAU,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;AAWxG,oBAAY,iBAAiB,GAAG,CAAC,CAAC,EAAE,aAAa,EAAE,CAAC,EAAE,aAAa,KAAK,MAAM,CAAC;AAe/E,oBAAY,kBAAkB,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,aAAa,EAAE,CAAC;AAUvG,oBAAY,oBAAoB,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAAK,MAAM,EAAE,EAAE,CAAC;;;;;;;;;;;;AAOpG,wBAUE","file":"external_helpers.d.ts","sourcesContent":["import proj4 from 'proj4';\nimport { LatLngLiteral } from '.';\n\n\ntype Projection = \"GMAPS\" | \"RT90\" | \"SWEREF99\" | \"WGS84\";\n\nconst EARTH_RADIUS = 6378137;\n\n////////////EXPORTED HELPER FUNCTIONS\n//Check Map.helpers for usage.\n\nexport type convertFromArrayOfArray = (fromProj: Projection, toProj: Projection, points: [number, number][]) => [number, number][];\nconst convertFromArrayOfArray: convertFromArrayOfArray = (fromProj, toProj, points) => {\n    return proj4(fromProj, toProj, points);\n};\n\nexport type arrayToLatLngObject = (coords: [number, number][], invert: boolean) => LatLngLiteral[];\nconst arrayToLatLngObject: arrayToLatLngObject = (arr, invert = false) => {\n    if (invert) {\n        return arr.map((point) => {\n            return { lat: point[1], lng: point[0] };\n        });\n    }\n    return arr.map((point) => {\n        return { lat: point[0], lng: point[1] };\n    });\n};\n\nexport type latLngArrayToCoordArray = (latLngArray: LatLngLiteral[], invert: boolean) => [number, number][];\nconst latLngArrayToCoordArray: latLngArrayToCoordArray = (arr, invert) => {\n    if (invert) {\n        return arr.map((point) => {\n            return [point.lng, point.lat] as [number, number];\n        });\n    }\n    return arr.map((point) => {\n        return [point.lat, point.lng] as [number, number];\n    });\n};\n\nexport type makePointsAroundCircleRT90 = (p: number[], r: number, numberOfPoints: number) => [number, number][];\nconst makePointsAroundCircleRT90: makePointsAroundCircleRT90 = (point, r, numberOfPoints = 12) => {\n    //Returns numberOfPoints around circle at p with r radius.\n\n    let points = [];\n    let i;\n\n    for (i = 0; i < numberOfPoints; i += 1) {\n        points.push([\n            point[0] + r * Math.cos(2 * Math.PI * i / numberOfPoints),\n            point[1] + r * Math.sin(2 * Math.PI * i / numberOfPoints)\n        ] as [number, number]);\n    }\n\n    return points;\n};\n\nexport type makeRectRT90 = (p1: number[], p2: number[]) => [number, number][];\nconst makeRectRT90: makeRectRT90 = (p1, p2) => {\n    //p1 and p2 should be opposite corners of the rectangle.\n    let points = [];\n\n    points.push(\n        [p1[0], p1[1]],\n        [p2[0], p1[1]],\n        [p2[0], p2[1]],\n        [p1[0], p2[1]]\n    );\n\n    return points as [number, number][];\n};\n\nexport type movePointsByCoord = (points_arr: [number, number][], coord: number[]) => [number, number][];\nconst movePointsByCoord: movePointsByCoord = (points_arr: [number, number][], coord: number[]) => {\n    //Adds value of Coord to all points in array.\n    return points_arr.map((point) => {\n        return [point[0] + coord[0], point[1] + coord[1]] as [number, number];\n    });\n};\n\n\nfunction squared(x: number): number { return x * x; }\nfunction toRad(x: number): number { return x * Math.PI / 180; }\nexport type haversineDistance = (a: LatLngLiteral, b: LatLngLiteral) => number;\nconst haversineDistance: haversineDistance = (a, b) => {\n    const aLat = a.lat;\n    const bLat = b.lat;\n    const aLng = a.lng;\n    const bLng = b.lng;\n    const dLat = toRad(bLat - aLat);\n    const dLon = toRad(bLng - aLng);\n\n    const f = squared(Math.sin(dLat / 2.0)) + Math.cos(toRad(aLat)) * Math.cos(toRad(bLat)) * squared(Math.sin(dLon / 2.0));\n    const c = 2 * Math.atan2(Math.sqrt(f), Math.sqrt(1 - f));\n\n    return EARTH_RADIUS * c;\n};\n\nexport type MVCArrayToObjArray = (MVCArr: google.maps.MVCArray<google.maps.LatLng>) => LatLngLiteral[];\nconst MVCArrayToObjArray: MVCArrayToObjArray = (MVCArr) => {\n    return MVCArr.getArray().map((gmapsLatLng) => {\n        return {\n            lat: gmapsLatLng.lat(),\n            lng: gmapsLatLng.lng()\n        };\n    });\n};\n\nexport type MVCArrayToCoordArray = (MVCArr: google.maps.MVCArray<google.maps.LatLng>) => number[][];\nconst MVCArrayToCoordArray: MVCArrayToCoordArray = (MVCArr) => {\n    return MVCArr.getArray().map((gmapsLatLng) => {\n        return [gmapsLatLng.lat(), gmapsLatLng.lng()];\n    });\n};\n\nexport default {\n    MVCArrayToObjArray,\n    MVCArrayToCoordArray,\n    haversineDistance,\n    convertFromArrayOfArray,\n    latLngArrayToCoordArray,\n    arrayToLatLngObject,\n    makeRectRT90,\n    movePointsByCoord,\n    makePointsAroundCircleRT90,\n};\n"]}