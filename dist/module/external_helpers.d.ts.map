{"version":3,"sources":["../src/module/external_helpers.ts"],"names":[],"mappings":";AAEA,OAAO,EAAE,iBAAiB,EAAE,MAAM,GAAG,CAAC;AAEtC,aAAK,UAAU,GAAG,OAAO,GAAG,MAAM,GAAG,UAAU,GAAG,OAAO,CAAC;AAK1D,gEAAgE;AAChE,oBAAY,2BAA2B,GAAG,CACxC,QAAQ,EAAE,UAAU,EACpB,MAAM,EAAE,UAAU,EAClB,MAAM,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,KACvB,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;AACxB,eAAO,MAAM,uBAAuB,EAAE,2BAMrC,CAAC;AACF,oBAAY,uBAAuB,GAAG,CACpC,MAAM,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,EAC1B,MAAM,EAAE,OAAO,KACZ,iBAAiB,EAAE,CAAC;AAEzB,0DAA0D;AAC1D,eAAO,MAAM,mBAAmB,EAAE,uBAM0B,CAAC;AAE7D,oBAAY,2BAA2B,GAAG,CACxC,WAAW,EAAE,iBAAiB,EAAE,EAChC,MAAM,EAAE,OAAO,KACZ,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,CAAC;AACxB,8CAA8C;AAC9C,eAAO,MAAM,uBAAuB,EAAE,2BAM8B,CAAC;AACrE,+DAA+D;AAC/D,eAAO,MAAM,0BAA0B,UAC9B,MAAM,EAAE,KACZ,MAAM,kBACO,MAAM,KACrB,CAAC,MAAM,EAAE,MAAM,CAAC,EAUlB,CAAC;AACF,gDAAgD;AAChD,eAAO,MAAM,YAAY,OACnB,MAAM,EAAE,MACR,MAAM,EAAE,KACX,CAAC,MAAM,EAAE,MAAM,CAAC,EAKlB,CAAC;AACF,0DAA0D;AAC1D,eAAO,MAAM,iBAAiB,eAChB,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,SACvB,MAAM,EAAE,KACd,CAAC,MAAM,EAAE,MAAM,CAAC,EAGhB,CAAC;AAIJ,iFAAiF;AACjF,eAAO,MAAM,iBAAiB,MACzB,iBAAiB,KACjB,iBAAiB,KACnB,MAgBF,CAAC;AAEF,oBAAY,sBAAsB,GAAG,CACnC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAC7C,iBAAiB,EAAE,CAAC;AACzB,qEAAqE;AACrE,eAAO,MAAM,kBAAkB,EAAE,sBAOhC,CAAC;AAEF,oBAAY,wBAAwB,GAAG,CACrC,MAAM,EAAE,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,KAC7C,MAAM,EAAE,EAAE,CAAC;AAEhB,kEAAkE;AAClE,eAAO,MAAM,oBAAoB,EAAE,wBAIlC,CAAC;AACF,eAAO,MAAM,gBAAgB,YAClB,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,KAC1B,CAAC,MAAM,EAAE,MAAM,CAAC,EAAuD,CAAC;AAC3E,qDAAqD;AACrD,eAAO,MAAM,yBAAyB,YAC3B,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,KAC1B,iBAAiB,EAC0D,CAAC","file":"external_helpers.d.ts","sourcesContent":["import proj4 from \"proj4\";\nimport { EARTH_RADIUS } from \"./constants\";\nimport { GMW_LatLngLiteral } from \".\";\n\ntype Projection = \"GMAPS\" | \"RT90\" | \"SWEREF99\" | \"WGS84\";\n\n////////////EXPORTED HELPER FUNCTIONS\n//Check Map.helpers for usage.\n\n/** Convert projection of points from 'fromProj' to 'toProj'. */\nexport type convertFromArrayOfArrayType = (\n  fromProj: Projection,\n  toProj: Projection,\n  points: [number, number][]\n) => [number, number][];\nexport const convertFromArrayOfArray: convertFromArrayOfArrayType = (\n  fromProj,\n  toProj,\n  points\n) => {\n  return points.map((point) => proj4(fromProj, toProj, point));\n};\nexport type arrayToLatLngObjectType = (\n  coords: [number, number][],\n  invert: boolean\n) => GMW_LatLngLiteral[];\n\n/** Convert coordinates to Google maps LatLngLiterals.  */\nexport const arrayToLatLngObject: arrayToLatLngObjectType = (\n  arr,\n  invert = false\n) =>\n  invert\n    ? arr.map((point) => ({ lat: point[1], lng: point[0] }))\n    : arr.map((point) => ({ lat: point[0], lng: point[1] }));\n\nexport type latLngArrayToCoordArrayType = (\n  latLngArray: GMW_LatLngLiteral[],\n  invert: boolean\n) => [number, number][];\n/** Convert array of latlng to coordinates. */\nexport const latLngArrayToCoordArray: latLngArrayToCoordArrayType = (\n  arr,\n  invert\n) =>\n  invert\n    ? arr.map((point) => [point.lng, point.lat] as [number, number])\n    : arr.map((point) => [point.lat, point.lng] as [number, number]);\n/** Returns numberOfPoints around circle at p with r radius. */\nexport const makePointsAroundCircleRT90 = (\n  point: number[],\n  r: number,\n  numberOfPoints: number\n): [number, number][] => {\n  const points = [];\n  for (let i = 0; i < numberOfPoints; i += 1) {\n    points.push([\n      point[0] + r * Math.cos((2 * Math.PI * i) / numberOfPoints),\n      point[1] + r * Math.sin((2 * Math.PI * i) / numberOfPoints),\n    ] as [number, number]);\n  }\n\n  return points;\n};\n/** Create an RT90 rectangle from two points. */\nexport const makeRectRT90 = (\n  p1: number[],\n  p2: number[]\n): [number, number][] => [\n  [p1[0], p1[1]],\n  [p2[0], p1[1]],\n  [p2[0], p2[1]],\n  [p1[0], p2[1]],\n];\n/** Move point by adding coordinates to point position. */\nexport const movePointsByCoord = (\n  points_arr: [number, number][],\n  coord: number[]\n): [number, number][] =>\n  points_arr.map(\n    (point) => [point[0] + coord[0], point[1] + coord[1]] as [number, number]\n  );\n\nconst squared = (x: number): number => x * x;\nconst toRad = (x: number): number => (x * Math.PI) / 180;\n/** Calculates Haversine distance between two points on earth. Result in meter.*/\nexport const haversineDistance = (\n  a: GMW_LatLngLiteral,\n  b: GMW_LatLngLiteral\n): number => {\n  const aLat = a.lat;\n  const bLat = b.lat;\n  const aLng = a.lng;\n  const bLng = b.lng;\n  const dLat = toRad(bLat - aLat);\n  const dLon = toRad(bLng - aLng);\n\n  const f =\n    squared(Math.sin(dLat / 2.0)) +\n    Math.cos(toRad(aLat)) *\n      Math.cos(toRad(bLat)) *\n      squared(Math.sin(dLon / 2.0));\n  const c = 2 * Math.atan2(Math.sqrt(f), Math.sqrt(1 - f));\n\n  return EARTH_RADIUS * c;\n};\n\nexport type MVCArrayToObjArrayType = (\n  MVCArr: google.maps.MVCArray<google.maps.LatLng>\n) => GMW_LatLngLiteral[];\n/** Convert a google maps MVC Array to an array of LatLngLiterals. */\nexport const MVCArrayToObjArray: MVCArrayToObjArrayType = (MVCArr) => {\n  return MVCArr.getArray().map((gmapsLatLng) => {\n    return {\n      lat: gmapsLatLng.lat(),\n      lng: gmapsLatLng.lng(),\n    };\n  });\n};\n\nexport type MVCArrayToCoordArrayType = (\n  MVCArr: google.maps.MVCArray<google.maps.LatLng>\n) => number[][];\n\n/** Convert a google maps MVC Array to an array of coordinates. */\nexport const MVCArrayToCoordArray: MVCArrayToCoordArrayType = (MVCArr) => {\n  return MVCArr.getArray().map((gmapsLatLng) => {\n    return [gmapsLatLng.lat(), gmapsLatLng.lng()];\n  });\n};\nexport const arrayRT90ToWGS84 = (\n  rt90arr: [number, number][]\n): [number, number][] => convertFromArrayOfArray(\"RT90\", \"WGS84\", rt90arr);\n/** Convert an array of rt90 coordinates to WGS84. */\nexport const arrayRT90ToWGS84LatLngObj = (\n  rt90arr: [number, number][]\n): GMW_LatLngLiteral[] =>\n  arrayToLatLngObject(convertFromArrayOfArray(\"RT90\", \"WGS84\", rt90arr), true);\n"]}