{"version":3,"sources":["../src/module/internal_helpers.ts"],"names":[],"mappings":"AAAA,OAAO,cAAc,EAAE,EAEnB,mBAAmB,EACnB,cAAc,EACd,eAAe,EACf,MAAM,EACN,aAAa,EACb,aAAa,EAEb,kBAAkB,EAClB,eAAe,EAEf,gBAAgB,EAChB,aAAa,EAEb,iBAAiB,EACjB,cAAc,EACd,cAAc,EACjB,MAAM,IAAI,CAAC;AAkBZ,wBAAgB,iBAAiB,CAAC,OAAO,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,OAcxE;AAED,wBAAgB,kBAAkB,CAAC,OAAO,EAAE,cAAc,EAAE,aAAa,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,eAqC5F;AACD,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,cAAc,EAAE,oBAAoB,EAAE,aAAa,EAAE,eAqCtG;AAED,wBAAgB,WAAW,CAAC,OAAO,EAAE,cAAc,EAAE,EAAE,EAAE,MAAM,GAAG,MAAM,EAAE,OAAO,EAAE,kBAAkB,GAAG,OAAO,CAAC,eAAe,CAAC,CAE/H;AACD,wBAAgB,UAAU,CAAC,OAAO,EAAE,cAAc,EAAE,EAAE,EAAE,MAAM,GAAG,MAAM,EAAE,OAAO,EAAE,iBAAiB,GAAG,OAAO,CAAC,cAAc,CAAC,CAE5H;AACD,wBAAgB,SAAS,CAAC,OAAO,EAAE,cAAc,EAAE,EAAE,EAAE,MAAM,GAAG,MAAM,EAAE,OAAO,EAAE,gBAAgB,GAAG,OAAO,CAAC,aAAa,CAAC,CAEzH;AAED,aAAK,YAAY,GAAG,CAChB,OAAO,EAAE,cAAc,EACvB,IAAI,EAAE,aAAa,EACnB,EAAE,EAAE,MAAM,GAAG,MAAM,EACnB,OAAO,EAAE,mBAAmB,EAC5B,kBAAkB,CAAC,EAAE,MAAM,KAC1B,OAAO,CAAC,eAAe,GAAC,cAAc,GAAC,aAAa,CAAC,CAAC;AAE3D,eAAO,MAAM,YAAY,EAAE,YAsK1B,CAAC;AAEF,wBAAgB,cAAc,CAAC,OAAO,EAAE,cAAc,EAAE,IAAI,EAAE,aAAa,EAAE,EAAE,EAAE,MAAM,GAAG,MAAM,oBA6B/F;AAED,wBAAgB,gBAAgB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,CAAC,EAAE,GAAG,WAUrH;AAED,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,cAAc,EAAE,GAAG,EAAE,aAAa,GAAG,cAAc,GAAG,eAAe,GAAG,cAAc,EAAE,IAAI,GAAE,OAAc,QAkE7J","file":"internal_helpers.d.ts","sourcesContent":["import WrappedMapBase, {\n    // AnyObjectOptions,\n    AnyObjectOptionsSet,\n    WrappedGmapObj,\n    AllMapObjEvents,\n    LatLng,\n    LatLngLiteral,\n    MapObjectType,\n    PolylineOptions,\n    PolylineOptionsSet,\n    WrappedPolyline,\n    MarkerOptions,\n    MarkerOptionsSet,\n    WrappedMarker,\n    PolygonOptions,\n    PolygonOptionsSet,\n    WrappedPolygon,\n    WrappedFeature\n} from './';\n\n/////////////////////////////////\n//INTERNAL MAP HELPER FUNCTIONS\n//These functions are not exported to enduser, only used\n//internally by the map.\n\nconst DEFAULT_POLYLINE_OPTIONS = {\n    visible: true\n};\nconst DEFAULT_POLYGON_OPTIONS = {\n    visible: true\n};\nconst DEFAULT_MARKER_OPTIONS = {\n    visible: true\n};\n\n\nexport function fromLatLngToPixel(map_ref: WrappedMapBase, latLng: LatLng) {\n    if (!map_ref.map) {\n        throw new Error(\"Cannot call fromLatLngToPixel before init is finished.\");\n    }\n    let map = map_ref.map;\n    let bounds = map.getBounds();\n    if (!bounds) {\n        throw new Error(\"Map not mounted when calling fromLatLngToPixel\");\n    }\n    var topRight = map.getProjection().fromLatLngToPoint(bounds.getNorthEast());\n    var bottomLeft = map.getProjection().fromLatLngToPoint(bounds.getSouthWest());\n    var scale = Math.pow(2, map.getZoom());\n    var worldPoint = map.getProjection().fromLatLngToPoint(latLng);\n    return new window.google.maps.Point((worldPoint.x - bottomLeft.x) * scale, (worldPoint.y - topRight.y) * scale);\n}\n\nexport function fitToBoundsOfArray(map_ref: WrappedMapBase, arr_of_coords: [number, number][]) {\n    //Takes [[x, y], ...] array.\n    return new Promise((resolve, reject) => {\n        if (Array.isArray(arr_of_coords) === false) {\n            reject(\"Input not valid array.\");\n        } else if (arr_of_coords.length < 1) {\n            reject(\"Array needs to countain at least one element.\");\n        }\n        if (!map_ref.initialized) {\n            map_ref.do_after_init.push(() => {\n                fitToBoundsOfArray(map_ref, arr_of_coords).then((res) => {\n                    resolve(res);\n                }).catch((err) => {\n                    reject(err);\n                });\n            });\n            return;\n        }\n        let lat_lng_literal = {\n            east: -99999999,\n            west: 99999999,\n            north: 99999999,\n            south: -99999999\n        };\n\n        arr_of_coords.forEach((point) => {\n            lat_lng_literal.west = (point[0] < lat_lng_literal.west) ? point[0] : lat_lng_literal.west;\n            lat_lng_literal.east = (point[0] > lat_lng_literal.east) ? point[0] : lat_lng_literal.east;\n            lat_lng_literal.north = (point[1] < lat_lng_literal.north) ? point[1] : lat_lng_literal.north;\n            lat_lng_literal.south = (point[1] > lat_lng_literal.south) ? point[1] : lat_lng_literal.south;\n        });\n\n        if (map_ref.map) {\n            map_ref.map.fitBounds(lat_lng_literal);\n        }\n        resolve();\n    });\n}\nexport function fitToBoundsOfObjectArray(map_ref: WrappedMapBase, arr_of_latlngliteral: LatLngLiteral[]) {\n    //Takes [{ lat: ?, lng: ? }, ...] array.\n    return new Promise((resolve, reject) => {\n        if (Array.isArray(arr_of_latlngliteral) === false) {\n            reject(\"Input not valid array.\");\n        } else if (arr_of_latlngliteral.length < 1) {\n            reject(\"Array needs to countain at least one element.\");\n        }\n        if (!map_ref.initialized) {\n            map_ref.do_after_init.push(() => {\n                fitToBoundsOfObjectArray(map_ref, arr_of_latlngliteral).then((res) => {\n                    resolve(res);\n                }).catch((err) => {\n                    reject(err);\n                });\n            });\n            return;\n        }\n        let lat_lng_literal = {\n            east: -99999999,\n            west: 99999999,\n            north: 99999999,\n            south: -99999999\n        };\n\n        arr_of_latlngliteral.forEach((point) => {\n            lat_lng_literal.west = (point.lng < lat_lng_literal.west) ? point.lng : lat_lng_literal.west;\n            lat_lng_literal.east = (point.lng > lat_lng_literal.east) ? point.lng : lat_lng_literal.east;\n            lat_lng_literal.north = (point.lat < lat_lng_literal.north) ? point.lat : lat_lng_literal.north;\n            lat_lng_literal.south = (point.lat > lat_lng_literal.south) ? point.lat : lat_lng_literal.south;\n        });\n\n        if (map_ref.map) {\n            map_ref.map.fitBounds(lat_lng_literal);\n        }\n        resolve();\n    });\n}\n\nexport function setPolyline(map_ref: WrappedMapBase, id: string | number, options: PolylineOptionsSet): Promise<WrappedPolyline> {\n    return setMapObject(map_ref, \"polyline\", id, options) as Promise<WrappedPolyline>;\n}\nexport function setPolygon(map_ref: WrappedMapBase, id: string | number, options: PolygonOptionsSet): Promise<WrappedPolygon> {\n    return setMapObject(map_ref, \"polygon\", id, options) as Promise<WrappedPolygon>;\n}\nexport function setMarker(map_ref: WrappedMapBase, id: string | number, options: MarkerOptionsSet): Promise<WrappedMarker> {\n    return setMapObject(map_ref, \"marker\", id, options) as Promise<WrappedMarker>;\n}\n\ntype setMapObject = (\n    map_ref: WrappedMapBase,\n    type: MapObjectType,\n    id: string | number,\n    options: AnyObjectOptionsSet,\n    current_options_id?: string\n) => Promise<WrappedPolyline|WrappedPolygon|WrappedMarker>;\n\nexport const setMapObject: setMapObject = (map_ref, type, id, options, selected_options_id = 'default') => {\n\n    return new Promise((resolve, reject) => {\n        if (!map_ref.initialized) {\n            map_ref.do_after_init.push(() => {\n                setMapObject(map_ref, type, id, options, selected_options_id).then((res) => {\n                    resolve(res);\n                }).catch((err) => {\n                    reject(err);\n                });\n            });\n            return;\n        }\n\n        if (map_ref.map_objects[type].hasOwnProperty(id)) {\n            //This ID has already been drawn.\n            let map_obj = map_ref.map_objects[type][id];\n            const visible = map_obj.gmaps_obj.getVisible();\n            let opts = Object.assign({}, map_obj.options[selected_options_id], options[selected_options_id], { visible: visible });\n            map_obj.selected_options_id = selected_options_id;\n            switch (map_obj.type) {\n                case \"polyline\": {\n                    map_obj.gmaps_obj.setOptions(opts as PolylineOptions);\n                    map_obj.options = options as PolylineOptionsSet;\n                    break;\n                }\n                case \"polygon\": {\n                    map_obj.gmaps_obj.setOptions(opts as PolygonOptions);\n                    map_obj.options = options as PolygonOptionsSet;\n                    break;\n                }\n                case \"marker\": {\n                    map_obj.gmaps_obj.setOptions(opts as MarkerOptions);\n                    map_obj.options = options as MarkerOptionsSet;\n                    break;\n                }\n                default: {\n                    reject(new Error(\"Invalid map object type.\"));\n                }\n            }\n            resolve(map_obj);\n            return;\n        }\n\n        //This extra interface exists so that _cbs can be created at different points in the following code.\n        //Otherwise ungainly \"hasOwnProperty\"-like checks are required.\n        interface MapObjShell extends Partial<WrappedGmapObj> {\n            _cbs: {\n                [key: string]: (e?: any) => void;\n            };\n            type: MapObjectType;\n            selected_options_id: string;\n        }\n\n        let map_obj_shell: MapObjShell = {\n            _cbs: {},\n            type: type,\n            selected_options_id: selected_options_id\n        };\n        let events: AllMapObjEvents[] = [];\n        let path_events: AllMapObjEvents[] = [];\n        switch (type) {\n            case \"marker\": {\n                let opts = Object.assign({}, DEFAULT_MARKER_OPTIONS, options.default);\n                map_obj_shell.gmaps_obj = new window.google.maps.Marker(opts);\n                map_obj_shell.options = opts;\n                events = [\"click\", \"mouseover\", \"mouseout\", \"mousedown\", \"mouseup\", \"dragstart\", \"drag\", \"dragend\", \"dblclick\", \"rightclick\"];\n                break;\n            }\n            case \"polygon\": {\n                let opts = Object.assign({}, DEFAULT_POLYGON_OPTIONS, options.default);\n                map_obj_shell.gmaps_obj = new window.google.maps.Polygon(opts);\n                map_obj_shell.options = opts;\n                events = [\"click\", \"dblclick\", \"dragstart\", \"drag\", \"dragend\", \"mouseover\", \"mouseout\", \"mousedown\", \"mouseup\", \"mousemove\", \"rightclick\"];\n                path_events = [\"set_at\", \"remove_at\", \"insert_at\"];\n                break;\n            }\n            case \"polyline\": {\n                let opts = Object.assign({}, DEFAULT_POLYLINE_OPTIONS, options.default);\n                map_obj_shell.gmaps_obj = new window.google.maps.Polyline(opts);\n                map_obj_shell.options = opts;\n                events = [\"click\", \"dblclick\", \"dragstart\", \"drag\", \"dragend\", \"mouseover\", \"mouseout\", \"mousedown\", \"mouseup\", \"mousemove\", \"rightclick\"];\n                path_events = [\"set_at\", \"remove_at\", \"insert_at\"];\n                break;\n            }\n            default: {\n                reject(new Error(\"Invalid map object type.\"));\n                return;\n            }\n        }\n\n\n        map_obj_shell.registerEventCB = (event_type: string, cb) => {\n            map_obj_shell._cbs[event_type] = cb;\n        };\n        map_obj_shell.unregisterEventCB = (event_type) => {\n            if (map_obj_shell._cbs.hasOwnProperty(event_type)) {\n                delete map_obj_shell._cbs[event_type];\n            }\n        };\n\n\n        map_obj_shell.remove = () => { return unsetMapObject(map_ref, type, id); };\n        map_obj_shell.setOptions = (new_options) => { return setMapObject(map_ref, type, id, new_options, map_obj_shell.selected_options_id); };\n        map_obj_shell.applyOptions = (options_id) => {\n            map_obj_shell.selected_options_id = options_id;\n            const visible = (map_obj_shell.gmaps_obj as google.maps.Polygon).getVisible();\n            const opts_set = map_obj_shell.options;\n            map_obj_shell.gmaps_obj.setOptions(Object.assign({}, opts_set.default, opts_set[options_id], { visible: visible }));\n        };\n        map_obj_shell.hide = () => {\n            map_obj_shell.gmaps_obj.setOptions(Object.assign({}, map_obj_shell.options[map_obj_shell.selected_options_id], { visible: false }));\n        };\n        map_obj_shell.show = () => {\n            map_obj_shell.gmaps_obj.setOptions(Object.assign({}, map_obj_shell.options[map_obj_shell.selected_options_id], { visible: true }));\n        };\n        let map_obj = map_obj_shell as WrappedGmapObj;\n        events.forEach((event_type) => {\n            map_obj.gmaps_obj.addListener(event_type, (e: any) => { return mapObjectEventCB(map_ref, map_obj, event_type, e); });\n        });\n        path_events.forEach((event_type) => {\n            map_obj.gmaps_obj.getPath().addListener(event_type, (e: any) => { return mapObjectEventCB(map_ref, map_obj, event_type, e); });\n        });\n\n        map_obj.gmaps_obj.setMap(map_ref.map);\n\n        switch (map_obj.type) {\n            case \"polyline\": {\n                map_obj.zoomTo = () => {\n                    panZoomToObjectOrFeature(map_ref, map_obj as WrappedPolyline, true);\n                };\n                map_obj.panTo = () => {\n                    panZoomToObjectOrFeature(map_ref, map_obj as WrappedPolyline, false);\n                };\n                map_ref.map_objects[type][id] = map_obj as WrappedPolyline;\n                resolve(map_obj as WrappedPolyline);\n                break;\n            }\n            case \"polygon\": {\n                map_obj.zoomTo = () => {\n                    panZoomToObjectOrFeature(map_ref, map_obj as WrappedPolygon, true);\n                };\n                map_obj.panTo = () => {\n                    panZoomToObjectOrFeature(map_ref, map_obj as WrappedPolygon, false);\n                };\n                map_ref.map_objects[type][id] = map_obj as WrappedPolygon;\n                resolve(map_obj as WrappedPolygon);\n                break;\n            }\n            case \"marker\": {\n                map_obj.zoomTo = () => {\n                    panZoomToObjectOrFeature(map_ref, map_obj as WrappedMarker, true);\n                };\n                map_obj.panTo = () => {\n                    panZoomToObjectOrFeature(map_ref, map_obj as WrappedMarker, false);\n                };\n                map_ref.map_objects[type][id] = map_obj as WrappedMarker;\n                resolve(map_obj as WrappedMarker);\n                break;\n            }\n            default: {\n                reject(new Error(\"Invalid map object type.\"));\n            }\n        }\n        return;\n    });\n};\n\nexport function unsetMapObject(map_ref: WrappedMapBase, type: MapObjectType, id: string | number) {\n    return new Promise<boolean>((resolve, reject) => {\n        if (!map_ref.initialized) {\n            map_ref.do_after_init.push(() => {\n                unsetMapObject(map_ref, type, id).then((res) => {\n                    resolve(res);\n                }).catch((err) => {\n                    reject(err);\n                });\n            });\n            return;\n        }\n\n        if (map_ref.map_objects[type].hasOwnProperty(id)) {\n            //This ID has been drawn.\n\n            if (map_ref.cutting.id && map_ref.cutting.id !== id) {\n                //This object is currently being cut, it cannot be deleted.\n                reject(new Error(\"MAP: Object is currently in cuttingMode; it cannot be removed!\"));\n                return;\n            }\n\n            map_ref.map_objects[type][id].gmaps_obj.setMap(null);\n            delete map_ref.map_objects[type][id];\n            resolve(true);\n            return;\n        }\n        reject(new Error(\"MAP: MapObject does not exist.\"));\n    });\n}\n\nexport function mapObjectEventCB(map_ref: WrappedMapBase, map_obj: WrappedGmapObj, event_type: AllMapObjEvents, e: any) {\n    if (map_ref.cutting.enabled) {\n        //When the map is in cutting mode no object event callbacks are allowed.\n        return true;\n    }\n\n    if (map_obj._cbs.hasOwnProperty(event_type) && map_obj._cbs[event_type]) {\n        map_obj._cbs[event_type](e);\n    }\n    return true;\n}\n\nexport function panZoomToObjectOrFeature(map_ref: WrappedMapBase, obj: WrappedMarker | WrappedPolygon | WrappedPolyline | WrappedFeature, zoom: boolean = true) {\n    if (!map_ref.map) {\n        return;\n    }\n    if (obj.hasOwnProperty(\"gmaps_feature\")) {\n        if (zoom) {\n            map_ref.map.fitBounds((obj as WrappedFeature)._bbox);\n        } else {\n            map_ref.map.panToBounds((obj as WrappedFeature)._bbox);\n        }\n        return;\n    }\n\n    obj = obj as WrappedMarker | WrappedPolygon | WrappedPolyline; //Reset typing.\n    switch (obj.type) {\n        case \"marker\": {\n            let position = obj.gmaps_obj.getPosition();\n            map_ref.map.setCenter(position);\n            if (zoom) {\n                map_ref.map.setZoom(14);\n            }\n            break;\n        }\n        case \"polyline\": {\n            let bounds = {\n                north: -9999,\n                south: 9999,\n                west: 9999,\n                east: -9999\n            };\n            obj.gmaps_obj.getPath().forEach((point) => {\n                bounds.north = point.lat() > bounds.north ? point.lat() : bounds.north;\n                bounds.south = point.lat() < bounds.south ? point.lat() : bounds.south;\n                bounds.west = point.lng() < bounds.west ? point.lng() : bounds.west;\n                bounds.east = point.lng() > bounds.east ? point.lng() : bounds.east;\n            });\n            if (zoom) {\n                map_ref.map.fitBounds(bounds);\n            } else {\n                map_ref.map.panToBounds(bounds);\n            }\n            break;\n        }\n        case \"polygon\": {\n            let bounds = {\n                north: -9999,\n                south: 9999,\n                west: 9999,\n                east: -9999\n            };\n            obj.gmaps_obj.getPaths().forEach((path) => {\n                path.forEach((point) => {\n                    bounds.north = point.lat() > bounds.north ? point.lat() : bounds.north;\n                    bounds.south = point.lat() < bounds.south ? point.lat() : bounds.south;\n                    bounds.west = point.lng() < bounds.west ? point.lng() : bounds.west;\n                    bounds.east = point.lng() > bounds.east ? point.lng() : bounds.east;\n                });\n            });\n            if (zoom) {\n                map_ref.map.fitBounds(bounds);\n            } else {\n                map_ref.map.panToBounds(bounds);\n            }\n            break;\n        }\n    }\n}\n"]}