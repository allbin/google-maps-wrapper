{"version":3,"sources":["../src/module/internal_helpers.ts"],"names":[],"mappings":";AAeA,eAAO,MAAM,iBAAiB,2DAqB7B,CAAC;AAEF,eAAO,MAAM,kBAAkB,4EAgC3B,CAAC;AACL,eAAO,MAAM,kBAAkB,mFAS3B,CAAC;AACL,eAAO,MAAM,wBAAwB,6FAgCjC,CAAC;AAEL,eAAO,MAAM,WAAW,sJASrB,CAAC;AACJ,eAAO,MAAM,UAAU,oJASpB,CAAC;AACJ,eAAO,MAAM,SAAS,kJASnB,CAAC;AAEJ,aAAK,YAAY,GAAG,CAClB,GAAG,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,EACpB,WAAW,EAAE,UAAU,EACvB,OAAO,EAAE,YAAY,EACrB,IAAI,EAAE,aAAa,EACnB,EAAE,EAAE,MAAM,GAAG,MAAM,EACnB,OAAO,EAAE,mBAAmB,EAC5B,kBAAkB,CAAC,EAAE,MAAM,KACxB,OAAO,CAAC,eAAe,GAAG,cAAc,GAAG,aAAa,CAAC,CAAC;AAE/D,eAAO,MAAM,YAAY,EAAE,YAwPvB,CAAC;AAEL,eAAO,MAAM,cAAc,gHA0BvB,CAAC;AACL,eAAO,MAAM,gBAAgB,iGAkB5B,CAAC;AAEF,eAAO,MAAM,wBAAwB,wHAwEpC,CAAC","file":"internal_helpers.d.ts","sourcesContent":["/////////////////////////////////\n//INTERNAL MAP HELPER FUNCTIONS\n//These functions are not exported to enduser, only used\n//internally by the map.\n\nconst DEFAULT_POLYLINE_OPTIONS = {\n  visible: true,\n};\nconst DEFAULT_POLYGON_OPTIONS = {\n  visible: true,\n};\nconst DEFAULT_MARKER_OPTIONS = {\n  visible: true,\n};\n\nexport const fromLatLngToPixel = (\n  map: google.maps.Map,\n  latLng: LatLng\n): any => {\n  if (!map) {\n    throw new Error(\"Cannot call fromLatLngToPixel before init is finished.\");\n  }\n  const bounds = map.getBounds();\n  if (!bounds) {\n    throw new Error(\"Map not mounted when calling fromLatLngToPixel\");\n  }\n  const topRight = map.getProjection().fromLatLngToPoint(bounds.getNorthEast());\n  const bottomLeft = map\n    .getProjection()\n    .fromLatLngToPoint(bounds.getSouthWest());\n  const scale = Math.pow(2, map.getZoom());\n  const worldPoint = map.getProjection().fromLatLngToPoint(latLng);\n  return new window.google.maps.Point(\n    (worldPoint.x - bottomLeft.x) * scale,\n    (worldPoint.y - topRight.y) * scale\n  );\n};\n\nexport const fitToBoundsOfArray = (\n  map: google.maps.Map,\n  arr_of_coords: [number, number][]\n): Promise<void> =>\n  new Promise((resolve, reject) => {\n    if (Array.isArray(arr_of_coords) === false) {\n      reject(\"Input not valid array.\");\n    } else if (arr_of_coords.length < 1) {\n      reject(\"Array needs to countain at least one element.\");\n    }\n    const lat_lng_literal = {\n      east: Number.MIN_SAFE_INTEGER,\n      west: Number.MAX_SAFE_INTEGER,\n      north: Number.MAX_SAFE_INTEGER,\n      south: Number.MIN_SAFE_INTEGER,\n    };\n\n    arr_of_coords.forEach((point) => {\n      lat_lng_literal.west =\n        point[0] < lat_lng_literal.west ? point[0] : lat_lng_literal.west;\n      lat_lng_literal.east =\n        point[0] > lat_lng_literal.east ? point[0] : lat_lng_literal.east;\n      lat_lng_literal.north =\n        point[1] < lat_lng_literal.north ? point[1] : lat_lng_literal.north;\n      lat_lng_literal.south =\n        point[1] > lat_lng_literal.south ? point[1] : lat_lng_literal.south;\n    });\n\n    if (map) {\n      map.fitBounds(lat_lng_literal);\n    }\n    resolve();\n  });\nexport const fitToBoundsLiteral = (\n  bounds: LatLngBoundsLiteral,\n  map?: google.maps.Map\n): Promise<void> =>\n  new Promise((resolve) => {\n    if (map) {\n      map.fitBounds(bounds);\n    }\n    resolve();\n  });\nexport const fitToBoundsOfObjectArray = (\n  arr_of_latlngliteral: LatLngLiteral[],\n  map?: google.maps.Map\n): Promise<void> =>\n  new Promise((resolve, reject) => {\n    if (Array.isArray(arr_of_latlngliteral) === false) {\n      reject(\"Input not valid array.\");\n    } else if (arr_of_latlngliteral.length < 1) {\n      reject(\"Array needs to contain at least one element.\");\n    }\n    const lat_lng_literal = {\n      east: -Infinity,\n      west: Infinity,\n      north: Infinity,\n      south: -Infinity,\n    };\n\n    arr_of_latlngliteral.forEach((point) => {\n      lat_lng_literal.west =\n        point.lng < lat_lng_literal.west ? point.lng : lat_lng_literal.west;\n      lat_lng_literal.east =\n        point.lng > lat_lng_literal.east ? point.lng : lat_lng_literal.east;\n      lat_lng_literal.north =\n        point.lat < lat_lng_literal.north ? point.lat : lat_lng_literal.north;\n      lat_lng_literal.south =\n        point.lat > lat_lng_literal.south ? point.lat : lat_lng_literal.south;\n    });\n\n    if (map) {\n      map.fitBounds(lat_lng_literal);\n    }\n    resolve();\n  });\n\nexport const setPolyline = (\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  id: string | number,\n  options: PolylineOptionsSet\n): Promise<WrappedPolyline> =>\n  setMapObject(map, map_objects, cutting, \"polyline\", id, options) as Promise<\n    WrappedPolyline\n  >;\nexport const setPolygon = (\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  id: string | number,\n  options: PolygonOptionsSet\n): Promise<WrappedPolygon> =>\n  setMapObject(map, map_objects, cutting, \"polygon\", id, options) as Promise<\n    WrappedPolygon\n  >;\nexport const setMarker = (\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  id: string | number,\n  options: MarkerOptionsSet\n): Promise<WrappedMarker> =>\n  setMapObject(map, map_objects, cutting, \"marker\", id, options) as Promise<\n    WrappedMarker\n  >;\n\ntype setMapObject = (\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  type: MapObjectType,\n  id: string | number,\n  options: AnyObjectOptionsSet,\n  current_options_id?: string\n) => Promise<WrappedPolyline | WrappedPolygon | WrappedMarker>;\n\nexport const setMapObject: setMapObject = (\n  map,\n  map_objects,\n  cutting,\n  type,\n  id,\n  options,\n  selected_options_id = \"default\"\n) =>\n  new Promise((resolve, reject) => {\n    if (Object.prototype.hasOwnProperty.call(map_objects[type], id)) {\n      //This ID has already been drawn.\n      const map_obj = map_objects[type][id];\n      const visible = map_obj.gmaps_obj.getVisible();\n      const opts = Object.assign(\n        {},\n        map_obj.options[selected_options_id],\n        options[selected_options_id],\n        { visible: visible }\n      );\n      map_obj.selected_options_id = selected_options_id;\n      switch (map_obj.type) {\n        case \"polyline\": {\n          map_obj.gmaps_obj.setOptions(opts as PolylineOptions);\n          map_obj.options = options as PolylineOptionsSet;\n          break;\n        }\n        case \"polygon\": {\n          map_obj.gmaps_obj.setOptions(opts as PolygonOptions);\n          map_obj.options = options as PolygonOptionsSet;\n          break;\n        }\n        case \"marker\": {\n          map_obj.gmaps_obj.setOptions(opts as MarkerOptions);\n          map_obj.options = options as MarkerOptionsSet;\n          break;\n        }\n        default: {\n          reject(new Error(\"Invalid map object type.\"));\n        }\n      }\n      resolve(map_obj);\n      return;\n    }\n\n    //This extra interface exists so that _cbs can be created at different points in the following code.\n    //Otherwise ungainly \"hasOwnProperty\"-like checks are required.\n    interface MapObjShell extends Partial<WrappedGmapObj> {\n      _cbs: {\n        [key: string]: (e?: any) => void;\n      };\n      type: MapObjectType;\n      selected_options_id: string;\n    }\n\n    const map_obj_shell: MapObjShell = {\n      _cbs: {},\n      type: type,\n      selected_options_id: selected_options_id,\n    };\n    let events: AllMapObjEvents[] = [];\n    let path_events: AllMapObjEvents[] = [];\n    switch (type) {\n      case \"marker\": {\n        const opts = Object.assign({}, DEFAULT_MARKER_OPTIONS, options.default);\n        map_obj_shell.gmaps_obj = new window.google.maps.Marker(opts);\n        map_obj_shell.options = options;\n        events = [\n          \"click\",\n          \"mouseover\",\n          \"mouseout\",\n          \"mousedown\",\n          \"mouseup\",\n          \"dragstart\",\n          \"drag\",\n          \"dragend\",\n          \"dblclick\",\n          \"rightclick\",\n        ];\n        break;\n      }\n      case \"polygon\": {\n        const opts = Object.assign(\n          {},\n          DEFAULT_POLYGON_OPTIONS,\n          options.default\n        );\n        map_obj_shell.gmaps_obj = new window.google.maps.Polygon(opts);\n        map_obj_shell.options = options;\n        events = [\n          \"click\",\n          \"dblclick\",\n          \"dragstart\",\n          \"drag\",\n          \"dragend\",\n          \"mouseover\",\n          \"mouseout\",\n          \"mousedown\",\n          \"mouseup\",\n          \"mousemove\",\n          \"rightclick\",\n        ];\n        path_events = [\"set_at\", \"remove_at\", \"insert_at\"];\n        break;\n      }\n      case \"polyline\": {\n        const opts = Object.assign(\n          {},\n          DEFAULT_POLYLINE_OPTIONS,\n          options.default\n        );\n        map_obj_shell.gmaps_obj = new window.google.maps.Polyline(opts);\n        map_obj_shell.options = options;\n        events = [\n          \"click\",\n          \"dblclick\",\n          \"dragstart\",\n          \"drag\",\n          \"dragend\",\n          \"mouseover\",\n          \"mouseout\",\n          \"mousedown\",\n          \"mouseup\",\n          \"mousemove\",\n          \"rightclick\",\n        ];\n        path_events = [\"set_at\", \"remove_at\", \"insert_at\"];\n        break;\n      }\n      default: {\n        reject(new Error(\"Invalid map object type.\"));\n        return;\n      }\n    }\n\n    map_obj_shell.registerEventCB = (event_type: string, cb) => {\n      map_obj_shell._cbs[event_type] = cb;\n    };\n    map_obj_shell.unregisterEventCB = (event_type) => {\n      if (\n        Object.prototype.hasOwnProperty.call(map_obj_shell._cbs, event_type)\n      ) {\n        delete map_obj_shell._cbs[event_type];\n      }\n    };\n\n    map_obj_shell.remove = () => {\n      return unsetMapObject(map_objects, cutting, type, id);\n    };\n    map_obj_shell.setOptions = (new_options) => {\n      return setMapObject(\n        map,\n        map_objects,\n        cutting,\n        type,\n        id,\n        new_options,\n        map_obj_shell.selected_options_id\n      );\n    };\n    map_obj_shell.applyOptions = (options_id) => {\n      if (!Object.prototype.hasOwnProperty.call(options, options_id)) {\n        throw new Error(\n          \"Tried to applyOptions(options_id) with '\" +\n            options_id +\n            \"', but options for given id are not defined.\"\n        );\n      }\n      map_obj_shell.selected_options_id = options_id;\n      const visible = (map_obj_shell.gmaps_obj as google.maps.Polygon).getVisible();\n      const opts_set = map_obj_shell.options;\n      map_obj_shell.gmaps_obj.setOptions(\n        Object.assign({}, opts_set.default, opts_set[options_id], {\n          visible: visible,\n        })\n      );\n    };\n    map_obj_shell.hide = () => {\n      map_obj_shell.gmaps_obj.setOptions(\n        Object.assign(\n          {},\n          map_obj_shell.options[map_obj_shell.selected_options_id],\n          { visible: false }\n        )\n      );\n    };\n    map_obj_shell.show = () => {\n      map_obj_shell.gmaps_obj.setOptions(\n        Object.assign(\n          {},\n          map_obj_shell.options[map_obj_shell.selected_options_id],\n          { visible: true }\n        )\n      );\n    };\n    const map_obj = map_obj_shell as WrappedGmapObj;\n    events.forEach((event_type) => {\n      map_obj.gmaps_obj.addListener(event_type, (e: any) => {\n        return mapObjectEventCB(cutting, map_obj, event_type, e);\n      });\n    });\n    path_events.forEach((event_type) => {\n      map_obj.gmaps_obj.getPath().addListener(event_type, (e: any) => {\n        return mapObjectEventCB(cutting, map_obj, event_type, e);\n      });\n    });\n\n    map_obj.gmaps_obj.setMap(map);\n\n    switch (map_obj.type) {\n      case \"polyline\": {\n        map_obj.zoomTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as WrappedPolyline, true);\n        };\n        map_obj.panTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as WrappedPolyline, false);\n        };\n        map_objects[type][id] = map_obj as WrappedPolyline;\n        resolve(map_obj as WrappedPolyline);\n        break;\n      }\n      case \"polygon\": {\n        map_obj.zoomTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as WrappedPolygon, true);\n        };\n        map_obj.panTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as WrappedPolygon, false);\n        };\n        map_objects[type][id] = map_obj as WrappedPolygon;\n        resolve(map_obj as WrappedPolygon);\n        break;\n      }\n      case \"marker\": {\n        map_obj.zoomTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as WrappedMarker, true);\n        };\n        map_obj.panTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as WrappedMarker, false);\n        };\n        map_objects[type][id] = map_obj as WrappedMarker;\n        resolve(map_obj as WrappedMarker);\n        break;\n      }\n      default: {\n        reject(new Error(\"Invalid map object type.\"));\n      }\n    }\n    return;\n  });\n\nexport const unsetMapObject = (\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  type: MapObjectType,\n  id: string | number\n): Promise<boolean> =>\n  new Promise<boolean>((resolve, reject) => {\n    if (Object.prototype.hasOwnProperty.call(map_objects[type], id)) {\n      //This ID has been drawn.\n\n      if (cutting.id && cutting.id !== id) {\n        //This object is currently being cut, it cannot be deleted.\n        reject(\n          new Error(\n            \"MAP: Object is currently in cuttingMode; it cannot be removed!\"\n          )\n        );\n        return;\n      }\n\n      map_objects[type][id].gmaps_obj.setMap(null);\n      delete map_objects[type][id];\n      resolve(true);\n      return;\n    }\n    reject(new Error(\"MAP: MapObject does not exist.\"));\n  });\nexport const mapObjectEventCB = (\n  cutting: CuttingState,\n  map_obj: WrappedGmapObj,\n  event_type: AllMapObjEvents,\n  e: any\n): boolean => {\n  if (cutting.enabled) {\n    //When the map is in cutting mode no object event callbacks are allowed.\n    return true;\n  }\n\n  if (\n    Object.prototype.hasOwnProperty.call(map_obj._cbs, event_type) &&\n    map_obj._cbs[event_type]\n  ) {\n    map_obj._cbs[event_type](e);\n  }\n  return true;\n};\n\nexport const panZoomToObjectOrFeature = (\n  map: google.maps.Map,\n  obj: WrappedMarker | WrappedPolygon | WrappedPolyline | WrappedFeature,\n  zoom = true\n): void => {\n  if (!map) {\n    return;\n  }\n  if (Object.prototype.hasOwnProperty.call(obj, \"gmaps_feature\")) {\n    if (zoom) {\n      map.fitBounds((obj as WrappedFeature)._bbox);\n    } else {\n      map.panToBounds((obj as WrappedFeature)._bbox);\n    }\n    return;\n  }\n\n  obj = obj as WrappedMarker | WrappedPolygon | WrappedPolyline; //Reset typing.\n  switch (obj.type) {\n    case \"marker\": {\n      const position = obj.gmaps_obj.getPosition();\n      map.setCenter(position);\n      if (zoom) {\n        map.setZoom(14);\n      }\n      break;\n    }\n    case \"polyline\": {\n      const bounds = {\n        north: -Infinity,\n        south: Infinity,\n        west: Infinity,\n        east: -Infinity,\n      };\n      obj.gmaps_obj.getPath().forEach((point) => {\n        bounds.north = point.lat() > bounds.north ? point.lat() : bounds.north;\n        bounds.south = point.lat() < bounds.south ? point.lat() : bounds.south;\n        bounds.west = point.lng() < bounds.west ? point.lng() : bounds.west;\n        bounds.east = point.lng() > bounds.east ? point.lng() : bounds.east;\n      });\n      if (zoom) {\n        map.fitBounds(bounds);\n      } else {\n        map.panToBounds(bounds);\n      }\n      break;\n    }\n    case \"polygon\": {\n      const bounds = {\n        north: -Infinity,\n        south: Infinity,\n        west: Infinity,\n        east: -Infinity,\n      };\n      obj.gmaps_obj.getPaths().forEach((path) => {\n        path.forEach((point) => {\n          bounds.north =\n            point.lat() > bounds.north ? point.lat() : bounds.north;\n          bounds.south =\n            point.lat() < bounds.south ? point.lat() : bounds.south;\n          bounds.west = point.lng() < bounds.west ? point.lng() : bounds.west;\n          bounds.east = point.lng() > bounds.east ? point.lng() : bounds.east;\n        });\n      });\n      if (zoom) {\n        map.fitBounds(bounds);\n      } else {\n        map.panToBounds(bounds);\n      }\n      break;\n    }\n  }\n};\n"]}