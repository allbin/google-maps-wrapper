{"version":3,"sources":["../src/module/internal_helpers.ts"],"names":[],"mappings":"AAAA,OAAO,cAAc,EAAE,EAAE,gBAAgB,EAAE,cAAc,EAAE,eAAe,EAAE,MAAM,EAAE,aAAa,EAAE,aAAa,EAAE,eAAe,EAAE,eAAe,EAAE,aAAa,EAAE,aAAa,EAAkB,cAAc,EAAE,MAAM,IAAI,CAAC;AAkB7N,wBAAgB,iBAAiB,CAAC,OAAO,EAAE,cAAc,EAAE,MAAM,EAAE,MAAM,OAcxE;AAED,wBAAgB,kBAAkB,CAAC,OAAO,EAAE,cAAc,EAAE,aAAa,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,eAqC5F;AACD,wBAAgB,wBAAwB,CAAC,OAAO,EAAE,cAAc,EAAE,oBAAoB,EAAE,aAAa,EAAE,eAqCtG;AAED,wBAAgB,WAAW,CAAC,OAAO,EAAE,cAAc,EAAE,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,eAAe,EAAE,aAAa,GAAE,eAAe,GAAG,IAAW,GAAG,OAAO,CAAC,eAAe,CAAC,CAEjK;AACD,wBAAgB,UAAU,CAAC,OAAO,EAAE,cAAc,EAAE,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,eAAe,EAAE,aAAa,GAAE,eAAe,GAAG,IAAW,GAAG,OAAO,CAAC,cAAc,CAAC,CAE/J;AACD,wBAAgB,SAAS,CAAC,OAAO,EAAE,cAAc,EAAE,EAAE,EAAE,MAAM,EAAE,OAAO,EAAE,aAAa,EAAE,aAAa,GAAE,aAAa,GAAG,IAAW,GAAG,OAAO,CAAC,aAAa,CAAC,CAEzJ;AAED,aAAK,YAAY,GAAG,CAChB,OAAO,EAAE,cAAc,EACvB,IAAI,EAAE,aAAa,EACnB,EAAE,EAAE,MAAM,EACV,OAAO,EAAE,gBAAgB,EACzB,aAAa,EAAE,gBAAgB,GAAG,IAAI,KACrC,OAAO,CAAC,eAAe,GAAC,cAAc,GAAC,aAAa,CAAC,CAAC;AAE3D,eAAO,MAAM,YAAY,EAAE,YA0K1B,CAAC;AAEF,wBAAgB,cAAc,CAAC,OAAO,EAAE,cAAc,EAAE,IAAI,EAAE,aAAa,EAAE,EAAE,EAAE,MAAM,oBA6BtF;AAED,wBAAgB,gBAAgB,CAAC,OAAO,EAAE,cAAc,EAAE,OAAO,EAAE,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,CAAC,EAAE,GAAG,WAYrH","file":"internal_helpers.d.ts","sourcesContent":["import WrappedMapBase, { AnyObjectOptions, WrappedGmapObj, AllMapObjEvents, LatLng, LatLngLiteral, MapObjectType, PolylineOptions, WrappedPolyline, MarkerOptions, WrappedMarker, PolygonOptions, WrappedPolygon } from './';\n\n/////////////////////////////////\n//INTERNAL MAP HELPER FUNCTIONS\n//These functions are not exported to enduser, only used\n//internally by the map.\n\nconst DEFAULT_POLYLINE_OPTIONS = {\n    visible: true\n};\nconst DEFAULT_POLYGON_OPTIONS = {\n    visible: true\n};\nconst DEFAULT_MARKER_OPTIONS = {\n    visible: true\n};\n\n\nexport function fromLatLngToPixel(map_ref: WrappedMapBase, latLng: LatLng) {\n    if (!map_ref.map) {\n        throw new Error(\"Cannot call fromLatLngToPixel before init is finished.\");\n    }\n    let map = map_ref.map;\n    let bounds = map.getBounds();\n    if (!bounds) {\n        throw new Error(\"Map not mounted when calling fromLatLngToPixel\");\n    }\n    var topRight = map.getProjection().fromLatLngToPoint(bounds.getNorthEast());\n    var bottomLeft = map.getProjection().fromLatLngToPoint(bounds.getSouthWest());\n    var scale = Math.pow(2, map.getZoom());\n    var worldPoint = map.getProjection().fromLatLngToPoint(latLng);\n    return new window.google.maps.Point((worldPoint.x - bottomLeft.x) * scale, (worldPoint.y - topRight.y) * scale);\n}\n\nexport function fitToBoundsOfArray(map_ref: WrappedMapBase, arr_of_coords: [number, number][]) {\n    //Takes [[x, y], ...] array.\n    return new Promise((resolve, reject) => {\n        if (Array.isArray(arr_of_coords) === false) {\n            reject(\"Input not valid array.\");\n        } else if (arr_of_coords.length < 1) {\n            reject(\"Array needs to countain at least one element.\");\n        }\n        if (!map_ref.initialized) {\n            map_ref.do_after_init.push(() => {\n                fitToBoundsOfArray(map_ref, arr_of_coords).then((res) => {\n                    resolve(res);\n                }).catch((err) => {\n                    reject(err);\n                });\n            });\n            return;\n        }\n        let lat_lng_literal = {\n            east: -99999999,\n            west: 99999999,\n            north: 99999999,\n            south: -99999999\n        };\n\n        arr_of_coords.forEach((point) => {\n            lat_lng_literal.west = (point[0] < lat_lng_literal.west) ? point[0] : lat_lng_literal.west;\n            lat_lng_literal.east = (point[0] > lat_lng_literal.east) ? point[0] : lat_lng_literal.east;\n            lat_lng_literal.north = (point[1] < lat_lng_literal.north) ? point[1] : lat_lng_literal.north;\n            lat_lng_literal.south = (point[1] > lat_lng_literal.south) ? point[1] : lat_lng_literal.south;\n        });\n\n        if (map_ref.map) {\n            map_ref.map.fitBounds(lat_lng_literal);\n        }\n        resolve();\n    });\n}\nexport function fitToBoundsOfObjectArray(map_ref: WrappedMapBase, arr_of_latlngliteral: LatLngLiteral[]) {\n    //Takes [{ lat: ?, lng: ? }, ...] array.\n    return new Promise((resolve, reject) => {\n        if (Array.isArray(arr_of_latlngliteral) === false) {\n            reject(\"Input not valid array.\");\n        } else if (arr_of_latlngliteral.length < 1) {\n            reject(\"Array needs to countain at least one element.\");\n        }\n        if (!map_ref.initialized) {\n            map_ref.do_after_init.push(() => {\n                fitToBoundsOfObjectArray(map_ref, arr_of_latlngliteral).then((res) => {\n                    resolve(res);\n                }).catch((err) => {\n                    reject(err);\n                });\n            });\n            return;\n        }\n        let lat_lng_literal = {\n            east: -99999999,\n            west: 99999999,\n            north: 99999999,\n            south: -99999999\n        };\n\n        arr_of_latlngliteral.forEach((point) => {\n            lat_lng_literal.west = (point.lng < lat_lng_literal.west) ? point.lng : lat_lng_literal.west;\n            lat_lng_literal.east = (point.lng > lat_lng_literal.east) ? point.lng : lat_lng_literal.east;\n            lat_lng_literal.north = (point.lat < lat_lng_literal.north) ? point.lat : lat_lng_literal.north;\n            lat_lng_literal.south = (point.lat > lat_lng_literal.south) ? point.lat : lat_lng_literal.south;\n        });\n\n        if (map_ref.map) {\n            map_ref.map.fitBounds(lat_lng_literal);\n        }\n        resolve();\n    });\n}\n\nexport function setPolyline(map_ref: WrappedMapBase, id: string, options: PolylineOptions, hover_options: PolylineOptions | null = null): Promise<WrappedPolyline> {\n    return setMapObject(map_ref, \"polyline\", id, options, hover_options) as Promise<WrappedPolyline>;\n}\nexport function setPolygon(map_ref: WrappedMapBase, id: string, options: PolylineOptions, hover_options: PolylineOptions | null = null): Promise<WrappedPolygon> {\n    return setMapObject(map_ref, \"polygon\", id, options, hover_options) as Promise<WrappedPolygon>;\n}\nexport function setMarker(map_ref: WrappedMapBase, id: string, options: MarkerOptions, hover_options: MarkerOptions | null = null): Promise<WrappedMarker> {\n    return setMapObject(map_ref, \"marker\", id, options, hover_options) as Promise<WrappedMarker>;\n}\n\ntype setMapObject = (\n    map_ref: WrappedMapBase,\n    type: MapObjectType,\n    id: string,\n    options: AnyObjectOptions,\n    hover_options: AnyObjectOptions | null\n) => Promise<WrappedPolyline|WrappedPolygon|WrappedMarker>;\n\nexport const setMapObject: setMapObject = (map_ref, type, id, options, hover_options) => {\n\n    return new Promise((resolve, reject) => {\n        if (!map_ref.initialized) {\n            console.log(map_ref);\n            map_ref.do_after_init.push(() => {\n                setMapObject(map_ref, type, id, options, hover_options).then((res) => {\n                    resolve(res);\n                }).catch((err) => {\n                    reject(err);\n                });\n            });\n            return;\n        }\n\n        if (map_ref.map_objects[type].hasOwnProperty(id)) {\n            //This ID has already been drawn.\n            let map_obj = map_ref.map_objects[type][id];\n            let opts;\n            if (map_obj.hovered && hover_options) {\n                opts = Object.assign({}, map_obj.options, options, hover_options);\n            } else {\n                opts = Object.assign({}, map_obj.options, options);\n            }\n            switch (map_obj.type) {\n                case \"polyline\": {\n                    map_obj.gmaps_obj.setOptions(opts as PolylineOptions);\n                    map_obj.options = options as PolylineOptions;\n                    if (hover_options) { map_obj.hover_options = hover_options as PolylineOptions; }\n                    break;\n                }\n                case \"polygon\": {\n                    map_obj.gmaps_obj.setOptions(opts as PolygonOptions);\n                    map_obj.options = options as PolygonOptions;\n                    if (hover_options) { map_obj.hover_options = hover_options as PolygonOptions; }\n                    break;\n                }\n                case \"marker\": {\n                    map_obj.gmaps_obj.setOptions(opts as MarkerOptions);\n                    map_obj.options = options as MarkerOptions;\n                    if (hover_options) { map_obj.hover_options = hover_options as MarkerOptions; }\n                    break;\n                }\n                default: {\n                    reject(new Error(\"Invalid map object type.\"));\n                }\n            }\n            resolve(map_obj);\n            return;\n        }\n\n        //This extra interface exists so that _cbs can be created at different points in the following code.\n        //Otherwise ungainly \"hasOwnProperty\"-like checks are required.\n        interface MapObjShell extends Partial<WrappedGmapObj> {\n            _cbs: {\n                [key: string]: (e?: any) => void;\n            };\n        }\n\n        let map_obj_shell: MapObjShell = {\n            _cbs: {},\n            hovered: false,\n            type: type\n        };\n        let events: AllMapObjEvents[] = [];\n        let path_events: AllMapObjEvents[] = [];\n        switch (type) {\n            case \"marker\": {\n                let opts = Object.assign({}, DEFAULT_MARKER_OPTIONS, options);\n                map_obj_shell.gmaps_obj = new window.google.maps.Marker(opts);\n                map_obj_shell.options = opts;\n                events = [\"click\", \"mouseover\", \"mouseout\", \"mousedown\", \"mouseup\", \"dragstart\", \"drag\", \"dragend\", \"dblclick\", \"rightclick\"];\n                break;\n            }\n            case \"polygon\": {\n                let opts = Object.assign({}, DEFAULT_POLYGON_OPTIONS, options);\n                map_obj_shell.gmaps_obj = new window.google.maps.Polygon(opts);\n                map_obj_shell.options = opts;\n                events = [\"click\", \"dblclick\", \"dragstart\", \"drag\", \"dragend\", \"mouseover\", \"mouseout\", \"mousedown\", \"mouseup\", \"mousemove\", \"rightclick\"];\n                path_events = [\"set_at\", \"remove_at\", \"insert_at\"];\n                break;\n            }\n            case \"polyline\": {\n                let opts = Object.assign({}, DEFAULT_POLYLINE_OPTIONS, options);\n                map_obj_shell.gmaps_obj = new window.google.maps.Polyline(opts);\n                map_obj_shell.options = opts;\n                events = [\"click\", \"dblclick\", \"dragstart\", \"drag\", \"dragend\", \"mouseover\", \"mouseout\", \"mousedown\", \"mouseup\", \"mousemove\", \"rightclick\"];\n                path_events = [\"set_at\", \"remove_at\", \"insert_at\"];\n                break;\n            }\n            default: {\n                reject(new Error(\"Invalid map object type.\"));\n                return;\n            }\n        }\n        map_obj_shell.hover_options = hover_options;\n\n        map_obj_shell.registerEventCB = (event_type: string, cb) => {\n            map_obj_shell._cbs[event_type] = cb;\n        };\n        map_obj_shell.unregisterEventCB = (event_type) => {\n            if (map_obj_shell._cbs.hasOwnProperty(event_type)) {\n                delete map_obj_shell._cbs[event_type];\n            }\n        };\n\n        map_obj_shell.hover = () => {\n            if (!map_obj_shell.hover_options) { return; }\n            let opts = Object.assign({}, map_obj_shell.options, map_obj_shell.hover_options);\n            let whitelisted_opts = {\n                strokeColor: opts.strokeColor,\n                strokeWidth: opts.strokeWidth,\n                fillColor: opts.fillColor,\n                fillOpacity: opts.fillOpacity\n            };\n            map_obj_shell.gmaps_obj.setOptions(whitelisted_opts);\n            map_obj_shell.hovered = true;\n        };\n        map_obj_shell.unhover = () => {\n            let opts = Object.assign({}, map_obj_shell.options);\n            let whitelisted_opts = {\n                strokeColor: opts.strokeColor,\n                strokeWidth: opts.strokeWidth,\n                fillColor: opts.fillColor,\n                fillOpacity: opts.fillOpacity\n            };\n            map_obj_shell.gmaps_obj.setOptions(whitelisted_opts);\n            map_obj_shell.hovered = false;\n        };\n        map_obj_shell.remove = () => { return unsetMapObject(map_ref, type, id); };\n        map_obj_shell.update = (new_options) => { return setMapObject(map_ref, type, id, new_options, hover_options); };\n        map_obj_shell.updateHover = (new_hover_options) => { return setMapObject(map_ref, type, id, options, new_hover_options); };\n        map_obj_shell.hide = () => {\n            map_obj_shell.gmaps_obj.setOptions(Object.assign({}, map_obj_shell.options, { visible: false }));\n        };\n        map_obj_shell.show = () => {\n            map_obj_shell.gmaps_obj.setOptions(Object.assign({}, map_obj_shell.options, { visible: true }));\n        };\n        let map_obj = map_obj_shell as WrappedGmapObj;\n        events.forEach((event_type) => {\n            map_obj.gmaps_obj.addListener(event_type, (e: any) => { return mapObjectEventCB(map_ref, map_obj, event_type, e); });\n        });\n        path_events.forEach((event_type) => {\n            map_obj.gmaps_obj.getPath().addListener(event_type, (e: any) => { return mapObjectEventCB(map_ref, map_obj, event_type, e); });\n        });\n\n        map_obj.gmaps_obj.setMap(map_ref.map);\n\n        switch (map_obj.type) {\n            case \"polyline\": {\n                map_ref.map_objects[type][id] = map_obj as WrappedPolyline;\n                resolve(map_obj as WrappedPolyline);\n                break;\n            }\n            case \"polygon\": {\n                map_ref.map_objects[type][id] = map_obj as WrappedPolygon;\n                resolve(map_obj as WrappedPolygon);\n                break;\n            }\n            case \"marker\": {\n                map_ref.map_objects[type][id] = map_obj as WrappedMarker;\n                resolve(map_obj as WrappedMarker);\n                break;\n            }\n            default: {\n                reject(new Error(\"Invalid map object type.\"));\n            }\n        }\n        return;\n    });\n};\n\nexport function unsetMapObject(map_ref: WrappedMapBase, type: MapObjectType, id: string) {\n    return new Promise<boolean>((resolve, reject) => {\n        if (!map_ref.initialized) {\n            map_ref.do_after_init.push(() => {\n                unsetMapObject(map_ref, type, id).then((res) => {\n                    resolve(res);\n                }).catch((err) => {\n                    reject(err);\n                });\n            });\n            return;\n        }\n\n        if (map_ref.map_objects[type].hasOwnProperty(id)) {\n            //This ID has been drawn.\n\n            if (map_ref.cutting.id !== id) {\n                //This object is currently being cut, it cannot be deleted.\n                reject(new Error(\"MAP: Object is currently in cuttingMode; it cannot be removed!\"));\n                return;\n            }\n\n            map_ref.map_objects[type][id].gmaps_obj.setMap(null);\n            delete map_ref.map_objects[type][id];\n            resolve(true);\n            return;\n        }\n        reject(new Error(\"MAP: MapObject does not exist.\"));\n    });\n}\n\nexport function mapObjectEventCB(map_ref: WrappedMapBase, map_obj: WrappedGmapObj, event_type: AllMapObjEvents, e: any) {\n    if (map_ref.cutting.enabled) {\n        //When the map is in cutting mode no object event callbacks are allowed.\n        return true;\n    }\n    if (event_type === \"mouseover\") { map_obj.hover(); }\n    if (event_type === \"mouseout\") { map_obj.unhover(); }\n\n    if (map_obj._cbs.hasOwnProperty(event_type) && map_obj._cbs[event_type]) {\n        map_obj._cbs[event_type](e);\n    }\n    return true;\n}\n"]}