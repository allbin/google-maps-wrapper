{"version":3,"sources":["../src/module/internal_helpers.ts"],"names":[],"mappings":";AAKA,OAAO,EACL,UAAU,EACV,uBAAuB,EACvB,iBAAiB,EACjB,sBAAsB,EACtB,qBAAqB,EACrB,oBAAoB,EAIpB,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,EACjB,kBAAkB,EAClB,aAAa,EACb,kBAAkB,EAClB,gBAAgB,EAChB,kBAAkB,EAClB,iBAAiB,EAClB,MAAM,GAAG,CAAC;AACX,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,MAAM,kBAAkB,CAAC;AAE5D,aAAK,mBAAmB,GACpB,oBAAoB,GACpB,sBAAsB,GACtB,qBAAqB,CAAC;AAE1B,aAAK,eAAe,GAChB,gBAAgB,GAChB,kBAAkB,GAClB,iBAAiB,CAAC;AAYtB,eAAO,MAAM,iBAAiB,QACvB,MAAM,CAAC,IAAI,CAAC,GAAG,UACZ,UAAU,KACjB,GAkBF,CAAC;AAEF,eAAO,MAAM,kBAAkB,QACxB,MAAM,CAAC,IAAI,CAAC,GAAG,iBACL,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,KAChC,OAAO,CAAC,IAAI,CA6BX,CAAC;AACL,eAAO,MAAM,kBAAkB,WACrB,uBAAuB,wCAE9B,OAAO,CAAC,IAAI,CAMX,CAAC;AACL,eAAO,MAAM,wBAAwB,yBACb,iBAAiB,EAAE,wCAExC,OAAO,CAAC,IAAI,CA6BX,CAAC;AAEL,eAAO,MAAM,WAAW,YACb,OAAO,OACX,MAAM,CAAC,IAAI,CAAC,GAAG,eACP,UAAU,WACd,YAAY,MACjB,MAAM,GAAG,MAAM,WACV,sBAAsB,KAC9B,OAAO,CAAC,mBAAmB,CASK,CAAC;AACpC,eAAO,MAAM,UAAU,YACZ,OAAO,OACX,MAAM,CAAC,IAAI,CAAC,GAAG,eACP,UAAU,WACd,YAAY,MACjB,MAAM,GAAG,MAAM,WACV,qBAAqB,KAC7B,OAAO,CAAC,kBAAkB,CASK,CAAC;AACnC,eAAO,MAAM,SAAS,YACX,OAAO,OACX,MAAM,CAAC,IAAI,CAAC,GAAG,eACP,UAAU,WACd,YAAY,MACjB,MAAM,GAAG,MAAM,WACV,oBAAoB,KAC5B,OAAO,CAAC,iBAAiB,CASK,CAAC;AAElC,aAAK,YAAY,GAAG,CAClB,OAAO,EAAE,OAAO,EAChB,GAAG,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,EACpB,WAAW,EAAE,UAAU,EACvB,OAAO,EAAE,YAAY,EACrB,IAAI,EAAE,aAAa,EACnB,EAAE,EAAE,MAAM,GAAG,MAAM,EACnB,OAAO,EAAE,mBAAmB,EAC5B,kBAAkB,CAAC,EAAE,MAAM,KACxB,OAAO,CAAC,mBAAmB,GAAG,kBAAkB,GAAG,iBAAiB,CAAC,CAAC;AAE3E,eAAO,MAAM,YAAY,EAAE,YA0PvB,CAAC;AAEL,eAAO,MAAM,cAAc,YAChB,OAAO,eACH,UAAU,WACd,YAAY,QACf,aAAa,MACf,MAAM,GAAG,MAAM,KAClB,OAAO,CAAC,OAAO,CAwBd,CAAC;AACL,eAAO,MAAM,gBAAgB,YAClB,YAAY,WACZ,kBAAkB,cACf,eAAe,KACxB,GAAG,KACL,OAaF,CAAC;AAEF,eAAO,MAAM,wBAAwB,QAC9B,MAAM,CAAC,IAAI,CAAC,GAAG,OAEhB,iBAAiB,GACjB,kBAAkB,GAClB,mBAAmB,GACnB,kBAAkB,qBAErB,IAoEF,CAAC","file":"internal_helpers.d.ts","sourcesContent":["/////////////////////////////////\n//INTERNAL MAP HELPER FUNCTIONS\n//These functions are not exported to enduser, only used\n//internally by the map.\n\nimport {\n  GMW_LatLng,\n  GMW_LatLngBoundsLiteral,\n  GMW_LatLngLiteral,\n  GMW_PolylineOptionsSet,\n  GMW_PolygonOptionsSet,\n  GMW_MarkerOptionsSet,\n  GMW_PolylineOptions,\n  GMW_PolygonOptions,\n  GMW_MarkerOptions,\n  GMW_WrappedPolyline,\n  GMW_WrappedPolygon,\n  GMW_WrappedMarker,\n  GMW_WrappedFeature,\n  MapObjectType,\n  GMW_WrappedGmapObj,\n  GMW_MarkerEvents,\n  GMW_PolylineEvents,\n  GMW_PolygonEvents,\n} from \".\";\nimport { MapObjects, CuttingState } from \"./WrappedMapBase\";\n\ntype AnyObjectOptionsSet =\n  | GMW_MarkerOptionsSet\n  | GMW_PolylineOptionsSet\n  | GMW_PolygonOptionsSet;\n\ntype AllMapObjEvents =\n  | GMW_MarkerEvents\n  | GMW_PolylineEvents\n  | GMW_PolygonEvents;\n\nconst DEFAULT_POLYLINE_OPTIONS = {\n  visible: true,\n};\nconst DEFAULT_POLYGON_OPTIONS = {\n  visible: true,\n};\nconst DEFAULT_MARKER_OPTIONS = {\n  visible: true,\n};\n\nexport const fromLatLngToPixel = (\n  map: google.maps.Map,\n  latLng: GMW_LatLng\n): any => {\n  if (!map) {\n    throw new Error(\"Cannot call fromLatLngToPixel before init is finished.\");\n  }\n  const bounds = map.getBounds();\n  if (!bounds) {\n    throw new Error(\"Map not mounted when calling fromLatLngToPixel\");\n  }\n  const topRight = map.getProjection().fromLatLngToPoint(bounds.getNorthEast());\n  const bottomLeft = map\n    .getProjection()\n    .fromLatLngToPoint(bounds.getSouthWest());\n  const scale = Math.pow(2, map.getZoom());\n  const worldPoint = map.getProjection().fromLatLngToPoint(latLng);\n  return new window.google.maps.Point(\n    (worldPoint.x - bottomLeft.x) * scale,\n    (worldPoint.y - topRight.y) * scale\n  );\n};\n\nexport const fitToBoundsOfArray = (\n  map: google.maps.Map,\n  arr_of_coords: [number, number][]\n): Promise<void> =>\n  new Promise((resolve, reject) => {\n    if (Array.isArray(arr_of_coords) === false) {\n      reject(\"Input not valid array.\");\n    } else if (arr_of_coords.length < 1) {\n      reject(\"Array needs to countain at least one element.\");\n    }\n    const lat_lng_literal = {\n      east: Number.MIN_SAFE_INTEGER,\n      west: Number.MAX_SAFE_INTEGER,\n      north: Number.MAX_SAFE_INTEGER,\n      south: Number.MIN_SAFE_INTEGER,\n    };\n\n    arr_of_coords.forEach((point) => {\n      lat_lng_literal.west =\n        point[0] < lat_lng_literal.west ? point[0] : lat_lng_literal.west;\n      lat_lng_literal.east =\n        point[0] > lat_lng_literal.east ? point[0] : lat_lng_literal.east;\n      lat_lng_literal.north =\n        point[1] < lat_lng_literal.north ? point[1] : lat_lng_literal.north;\n      lat_lng_literal.south =\n        point[1] > lat_lng_literal.south ? point[1] : lat_lng_literal.south;\n    });\n\n    if (map) {\n      map.fitBounds(lat_lng_literal);\n    }\n    resolve();\n  });\nexport const fitToBoundsLiteral = (\n  bounds: GMW_LatLngBoundsLiteral,\n  map?: google.maps.Map\n): Promise<void> =>\n  new Promise((resolve) => {\n    if (map) {\n      map.fitBounds(bounds);\n    }\n    resolve();\n  });\nexport const fitToBoundsOfObjectArray = (\n  arr_of_latlngliteral: GMW_LatLngLiteral[],\n  map?: google.maps.Map\n): Promise<void> =>\n  new Promise((resolve, reject) => {\n    if (Array.isArray(arr_of_latlngliteral) === false) {\n      reject(\"Input not valid array.\");\n    } else if (arr_of_latlngliteral.length < 1) {\n      reject(\"Array needs to contain at least one element.\");\n    }\n    const lat_lng_literal = {\n      east: -Infinity,\n      west: Infinity,\n      north: Infinity,\n      south: -Infinity,\n    };\n\n    arr_of_latlngliteral.forEach((point) => {\n      lat_lng_literal.west =\n        point.lng < lat_lng_literal.west ? point.lng : lat_lng_literal.west;\n      lat_lng_literal.east =\n        point.lng > lat_lng_literal.east ? point.lng : lat_lng_literal.east;\n      lat_lng_literal.north =\n        point.lat < lat_lng_literal.north ? point.lat : lat_lng_literal.north;\n      lat_lng_literal.south =\n        point.lat > lat_lng_literal.south ? point.lat : lat_lng_literal.south;\n    });\n\n    if (map) {\n      map.fitBounds(lat_lng_literal);\n    }\n    resolve();\n  });\n\nexport const setPolyline = (\n  verbose: boolean,\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  id: string | number,\n  options: GMW_PolylineOptionsSet\n): Promise<GMW_WrappedPolyline> =>\n  setMapObject(\n    verbose,\n    map,\n    map_objects,\n    cutting,\n    \"polyline\",\n    id,\n    options\n  ) as Promise<GMW_WrappedPolyline>;\nexport const setPolygon = (\n  verbose: boolean,\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  id: string | number,\n  options: GMW_PolygonOptionsSet\n): Promise<GMW_WrappedPolygon> =>\n  setMapObject(\n    verbose,\n    map,\n    map_objects,\n    cutting,\n    \"polygon\",\n    id,\n    options\n  ) as Promise<GMW_WrappedPolygon>;\nexport const setMarker = (\n  verbose: boolean,\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  id: string | number,\n  options: GMW_MarkerOptionsSet\n): Promise<GMW_WrappedMarker> =>\n  setMapObject(\n    verbose,\n    map,\n    map_objects,\n    cutting,\n    \"marker\",\n    id,\n    options\n  ) as Promise<GMW_WrappedMarker>;\n\ntype setMapObject = (\n  verbose: boolean,\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  type: MapObjectType,\n  id: string | number,\n  options: AnyObjectOptionsSet,\n  current_options_id?: string\n) => Promise<GMW_WrappedPolyline | GMW_WrappedPolygon | GMW_WrappedMarker>;\n\nexport const setMapObject: setMapObject = (\n  verbose,\n  map,\n  map_objects,\n  cutting,\n  type,\n  id,\n  options,\n  selected_options_id = \"default\"\n) =>\n  new Promise((resolve, reject) => {\n    if (Object.prototype.hasOwnProperty.call(map_objects[type], id)) {\n      //This ID has already been drawn.\n      const map_obj = map_objects[type][id];\n      const visible = map_obj.gmaps_obj.getVisible();\n      const opts = Object.assign(\n        {},\n        map_obj.options[selected_options_id],\n        options[selected_options_id],\n        { visible: visible }\n      );\n      map_obj.selected_options_id = selected_options_id;\n      switch (map_obj.type) {\n        case \"polyline\": {\n          map_obj.gmaps_obj.setOptions(opts as GMW_PolylineOptions);\n          map_obj.options = options as GMW_PolylineOptionsSet;\n          break;\n        }\n        case \"polygon\": {\n          map_obj.gmaps_obj.setOptions(opts as GMW_PolygonOptions);\n          map_obj.options = options as GMW_PolygonOptionsSet;\n          break;\n        }\n        case \"marker\": {\n          map_obj.gmaps_obj.setOptions(opts as GMW_MarkerOptions);\n          map_obj.options = options as GMW_MarkerOptionsSet;\n          break;\n        }\n        default: {\n          reject(new Error(\"Invalid map object type.\"));\n        }\n      }\n      resolve(map_obj);\n      return;\n    }\n\n    //This extra interface exists so that _cbs can be created at different points in the following code.\n    //Otherwise ungainly \"hasOwnProperty\"-like checks are required.\n    interface MapObjShell extends Partial<GMW_WrappedGmapObj> {\n      _cbs: {\n        [key: string]: (e?: any) => void;\n      };\n      type: MapObjectType;\n      selected_options_id: string;\n    }\n\n    const map_obj_shell: MapObjShell = {\n      _cbs: {},\n      type: type,\n      selected_options_id: selected_options_id,\n    };\n    let events: AllMapObjEvents[] = [];\n    let path_events: AllMapObjEvents[] = [];\n    switch (type) {\n      case \"marker\": {\n        const opts = Object.assign({}, DEFAULT_MARKER_OPTIONS, options.default);\n        map_obj_shell.gmaps_obj = new window.google.maps.Marker(opts);\n        map_obj_shell.options = options;\n        events = [\n          \"click\",\n          \"mouseover\",\n          \"mouseout\",\n          \"mousedown\",\n          \"mouseup\",\n          \"dragstart\",\n          \"drag\",\n          \"dragend\",\n          \"dblclick\",\n          \"rightclick\",\n        ];\n        break;\n      }\n      case \"polygon\": {\n        const opts = Object.assign(\n          {},\n          DEFAULT_POLYGON_OPTIONS,\n          options.default\n        );\n        map_obj_shell.gmaps_obj = new window.google.maps.Polygon(opts);\n        map_obj_shell.options = options;\n        events = [\n          \"click\",\n          \"dblclick\",\n          \"dragstart\",\n          \"drag\",\n          \"dragend\",\n          \"mouseover\",\n          \"mouseout\",\n          \"mousedown\",\n          \"mouseup\",\n          \"mousemove\",\n          \"rightclick\",\n        ];\n        path_events = [\"set_at\", \"remove_at\", \"insert_at\"];\n        break;\n      }\n      case \"polyline\": {\n        const opts = Object.assign(\n          {},\n          DEFAULT_POLYLINE_OPTIONS,\n          options.default\n        );\n        map_obj_shell.gmaps_obj = new window.google.maps.Polyline(opts);\n        map_obj_shell.options = options;\n        events = [\n          \"click\",\n          \"dblclick\",\n          \"dragstart\",\n          \"drag\",\n          \"dragend\",\n          \"mouseover\",\n          \"mouseout\",\n          \"mousedown\",\n          \"mouseup\",\n          \"mousemove\",\n          \"rightclick\",\n        ];\n        path_events = [\"set_at\", \"remove_at\", \"insert_at\"];\n        break;\n      }\n      default: {\n        reject(new Error(\"Invalid map object type.\"));\n        return;\n      }\n    }\n\n    map_obj_shell.registerEventCB = (event_type: string, cb) => {\n      map_obj_shell._cbs[event_type] = cb;\n    };\n    map_obj_shell.unregisterEventCB = (event_type) => {\n      if (\n        Object.prototype.hasOwnProperty.call(map_obj_shell._cbs, event_type)\n      ) {\n        delete map_obj_shell._cbs[event_type];\n      }\n    };\n\n    map_obj_shell.remove = () => {\n      return unsetMapObject(verbose, map_objects, cutting, type, id);\n    };\n    map_obj_shell.setOptions = (new_options) => {\n      return setMapObject(\n        verbose,\n        map,\n        map_objects,\n        cutting,\n        type,\n        id,\n        new_options,\n        map_obj_shell.selected_options_id\n      );\n    };\n    map_obj_shell.applyOptions = (options_id) => {\n      if (!Object.prototype.hasOwnProperty.call(options, options_id)) {\n        throw new Error(\n          \"Tried to applyOptions(options_id) with '\" +\n            options_id +\n            \"', but options for given id are not defined.\"\n        );\n      }\n      map_obj_shell.selected_options_id = options_id;\n      const visible = (map_obj_shell.gmaps_obj as google.maps.Polygon).getVisible();\n      const opts_set = map_obj_shell.options;\n      map_obj_shell.gmaps_obj.setOptions(\n        Object.assign({}, opts_set.default, opts_set[options_id], {\n          visible: visible,\n        })\n      );\n    };\n    map_obj_shell.hide = () => {\n      map_obj_shell.gmaps_obj.setOptions(\n        Object.assign(\n          {},\n          map_obj_shell.options[map_obj_shell.selected_options_id],\n          { visible: false }\n        )\n      );\n    };\n    map_obj_shell.show = () => {\n      map_obj_shell.gmaps_obj.setOptions(\n        Object.assign(\n          {},\n          map_obj_shell.options[map_obj_shell.selected_options_id],\n          { visible: true }\n        )\n      );\n    };\n    const map_obj = map_obj_shell as GMW_WrappedGmapObj;\n    events.forEach((event_type) => {\n      map_obj.gmaps_obj.addListener(event_type, (e: any) => {\n        return mapObjectEventCB(cutting, map_obj, event_type, e);\n      });\n    });\n    path_events.forEach((event_type) => {\n      map_obj.gmaps_obj.getPath().addListener(event_type, (e: any) => {\n        return mapObjectEventCB(cutting, map_obj, event_type, e);\n      });\n    });\n\n    map_obj.gmaps_obj.setMap(map);\n\n    switch (map_obj.type) {\n      case \"polyline\": {\n        map_obj.zoomTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as GMW_WrappedPolyline, true);\n        };\n        map_obj.panTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as GMW_WrappedPolyline, false);\n        };\n        map_objects[type][id] = map_obj as GMW_WrappedPolyline;\n        resolve(map_obj as GMW_WrappedPolyline);\n        break;\n      }\n      case \"polygon\": {\n        map_obj.zoomTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as GMW_WrappedPolygon, true);\n        };\n        map_obj.panTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as GMW_WrappedPolygon, false);\n        };\n        map_objects[type][id] = map_obj as GMW_WrappedPolygon;\n        resolve(map_obj as GMW_WrappedPolygon);\n        break;\n      }\n      case \"marker\": {\n        map_obj.zoomTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as GMW_WrappedMarker, true);\n        };\n        map_obj.panTo = () => {\n          panZoomToObjectOrFeature(map, map_obj as GMW_WrappedMarker, false);\n        };\n        map_objects[type][id] = map_obj as GMW_WrappedMarker;\n        resolve(map_obj as GMW_WrappedMarker);\n        break;\n      }\n      default: {\n        reject(new Error(\"Invalid map object type.\"));\n      }\n    }\n    return;\n  });\n\nexport const unsetMapObject = (\n  verbose: boolean,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  type: MapObjectType,\n  id: string | number\n): Promise<boolean> =>\n  new Promise<boolean>((resolve, reject) => {\n    if (Object.prototype.hasOwnProperty.call(map_objects[type], id)) {\n      //This ID has been drawn.\n\n      if (cutting.id && cutting.id !== id) {\n        //This object is currently being cut, it cannot be deleted.\n        reject(\n          new Error(\n            \"MAP: Object is currently in cuttingMode; it cannot be removed!\"\n          )\n        );\n        return;\n      }\n\n      map_objects[type][id].gmaps_obj.setMap(null);\n      delete map_objects[type][id];\n      resolve(true);\n      return;\n    }\n    if (verbose) {\n      return reject(new Error(\"MAP: MapObject does not exist.\"));\n    }\n    return resolve(true);\n  });\nexport const mapObjectEventCB = (\n  cutting: CuttingState,\n  map_obj: GMW_WrappedGmapObj,\n  event_type: AllMapObjEvents,\n  e: any\n): boolean => {\n  if (cutting.enabled) {\n    //When the map is in cutting mode no object event callbacks are allowed.\n    return true;\n  }\n\n  if (\n    Object.prototype.hasOwnProperty.call(map_obj._cbs, event_type) &&\n    map_obj._cbs[event_type]\n  ) {\n    map_obj._cbs[event_type](e);\n  }\n  return true;\n};\n\nexport const panZoomToObjectOrFeature = (\n  map: google.maps.Map,\n  obj:\n    | GMW_WrappedMarker\n    | GMW_WrappedPolygon\n    | GMW_WrappedPolyline\n    | GMW_WrappedFeature,\n  zoom = true\n): void => {\n  if (!map) {\n    return;\n  }\n  if (Object.prototype.hasOwnProperty.call(obj, \"gmaps_feature\")) {\n    if (zoom) {\n      map.fitBounds((obj as GMW_WrappedFeature)._bbox);\n    } else {\n      map.panToBounds((obj as GMW_WrappedFeature)._bbox);\n    }\n    return;\n  }\n\n  obj = obj as GMW_WrappedMarker | GMW_WrappedPolygon | GMW_WrappedPolyline; //Reset typing.\n  switch (obj.type) {\n    case \"marker\": {\n      const position = obj.gmaps_obj.getPosition();\n      map.setCenter(position);\n      if (zoom) {\n        map.setZoom(14);\n      }\n      break;\n    }\n    case \"polyline\": {\n      const bounds = {\n        north: -Infinity,\n        south: Infinity,\n        west: Infinity,\n        east: -Infinity,\n      };\n      obj.gmaps_obj.getPath().forEach((point) => {\n        bounds.north = point.lat() > bounds.north ? point.lat() : bounds.north;\n        bounds.south = point.lat() < bounds.south ? point.lat() : bounds.south;\n        bounds.west = point.lng() < bounds.west ? point.lng() : bounds.west;\n        bounds.east = point.lng() > bounds.east ? point.lng() : bounds.east;\n      });\n      if (zoom) {\n        map.fitBounds(bounds);\n      } else {\n        map.panToBounds(bounds);\n      }\n      break;\n    }\n    case \"polygon\": {\n      const bounds = {\n        north: -Infinity,\n        south: Infinity,\n        west: Infinity,\n        east: -Infinity,\n      };\n      obj.gmaps_obj.getPaths().forEach((path) => {\n        path.forEach((point) => {\n          bounds.north =\n            point.lat() > bounds.north ? point.lat() : bounds.north;\n          bounds.south =\n            point.lat() < bounds.south ? point.lat() : bounds.south;\n          bounds.west = point.lng() < bounds.west ? point.lng() : bounds.west;\n          bounds.east = point.lng() > bounds.east ? point.lng() : bounds.east;\n        });\n      });\n      if (zoom) {\n        map.fitBounds(bounds);\n      } else {\n        map.panToBounds(bounds);\n      }\n      break;\n    }\n  }\n};\n"]}