{"version":3,"sources":["../src/module/index.tsx"],"names":[],"mappings":"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","file":"index.d.ts","sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport proj4 from 'proj4';\n\nimport ScriptCache from './ScriptCache';\nimport external_helpers, { MVCArrayToCoordArray, MVCArrayToObjArray, movePointsByCoord, makePointsAroundCircleRT90, makeRectRT90, convertFromArrayOfArray, arrayToLatLngObject, latLngArrayToCoordArray, haversineDistance} from './external_helpers';\nimport * as internal_helpers from './internal_helpers';\nlet ScissorIcon = require('./img/marker_scissors.svg');\nlet ScissorHoverIcon = require('./img/marker_scissors_hover.svg');\n\n\ndeclare global {\n    interface Window {\n        google: any;\n        wrapped_gmaps: any;\n    }\n}\n\nexport interface LatLngLiteral {\n    lat: number;\n    lng: number;\n}\nexport interface LatLng extends google.maps.LatLng {}\nexport interface MouseEvent extends google.maps.MouseEvent {}\nexport interface Polyline extends google.maps.Polyline {}\nexport interface PolylineOptions extends google.maps.PolylineOptions {}\nexport interface Polygon extends google.maps.Polygon {}\nexport interface PolygonOptions extends google.maps.PolygonOptions {}\nexport interface Marker extends google.maps.Marker {}\nexport interface MarkerOptions extends google.maps.MarkerOptions {}\n\nexport type MarkerEvents = \"click\" | \"mouseover\" | \"mouseout\" | \"mousedown\" | \"mouseup\" | \"dragstart\" | \"drag\" | \"dragend\" | \"dblclick\" | \"rightclick\";\nexport type PolylineEvents = \"click\" | \"dblclick\" | \"dragstart\" | \"drag\" | \"dragend\" | \"mouseover\" | \"mouseout\" | \"mousedown\" | \"mouseup\" | \"mousemove\" | \"rightclick\" | \"set_at\" | \"remove_at\" | \"insert_at\";\nexport type PolygonEvents = \"click\" | \"dblclick\" | \"dragstart\" | \"drag\" | \"dragend\" | \"mouseover\" | \"mouseout\" | \"mousedown\" | \"mouseup\" | \"mousemove\" | \"rightclick\" | \"set_at\" | \"remove_at\" | \"insert_at\";\nexport type AllMapObjEvents = MarkerEvents | PolylineEvents | PolygonEvents;\nexport interface MapBaseProps {\n    initializedCB?: (this_ref: WrappedMapBase) => void;\n    googleapi_maps_uri: string;\n    id?: string;\n    default_center: LatLngLiteral;\n    default_zoom: number;\n    default_options?: object;\n    onCenterChanged?: () => void;\n    onBoundsChanged?: () => void;\n    onClick?: (e: any) => void;\n    onDoubleClick?: (e: any) => void;\n    onDrag?: () => void;\n    onDragEnd?: () => void;\n    onDragStart?: () => void;\n    onHeadingChanged?: () => void;\n    onIdle?: () => void;\n    onMapTypeIdChanged?: () => void;\n    onMouseMove?: (e: any) => void;\n    onMouseOut?: (e: any) => void;\n    onMouseOver?: (e: any) => void;\n    onProjectionChanged?: () => void;\n    onResize?: () => void;\n    onRightClick?: (e: any) => void;\n    onTilesLoaded?: () => void;\n    onTiltChanged?: () => void;\n    onZoomChanged?: () => void;\n    styles?: object;\n}\n\nexport interface WrappedGmapObj {\n    gmaps_obj?: any;\n    type: MapObjectType;\n    hover: () => void;\n    hovered: boolean;\n    hover_options: any;\n    unhover: () => void;\n    show: () => void;\n    hide: () => void;\n    remove: () => void;\n    _cbs: {\n        [key: string]: (e?: any) => void;\n    };\n    registerEventCB: (event_type: MarkerEvents & PolygonEvents & PolylineEvents, cb: (e?: any) => void) => void;\n    unregisterEventCB: (event_type: MarkerEvents & PolygonEvents & PolylineEvents) => void;\n    options: any;\n    update: (options: any) => Promise<WrappedGmapObj>;\n    updateHover: (options: any) => Promise<WrappedGmapObj>;\n}\n\nexport interface WrappedPolygon extends WrappedGmapObj {\n    gmaps_obj: Polygon;\n    type: \"polygon\";\n    options: PolygonOptions;\n    hover_options: PolygonOptions;\n    update: (options: PolygonOptions) => Promise<WrappedPolygon>;\n    updateHover: (options: PolygonOptions) => Promise<WrappedPolygon>;\n    registerEventCB: (event_type: PolygonEvents, cb: (e?: any) => void) => void;\n    unregisterEventCB: (event_type: PolygonEvents) => void;\n}\nexport interface WrappedPolyline extends WrappedGmapObj {\n    gmaps_obj: Polyline;\n    type: \"polyline\";\n    options: PolylineOptions;\n    hover_options: PolylineOptions;\n    update: (options: PolylineOptions) => Promise<WrappedPolyline>;\n    updateHover: (options: PolylineOptions) => Promise<WrappedPolyline>;\n    registerEventCB: (event_type: PolylineEvents, cb: (e?: any) => void) => void;\n    unregisterEventCB: (event_type: PolylineEvents) => void;\n}\nexport interface WrappedMarker extends WrappedGmapObj {\n    gmaps_obj: Marker;\n    type: \"marker\";\n    options: MarkerOptions;\n    hover_options: MarkerOptions;\n    update: (options: MarkerOptions) => Promise<WrappedMarker>;\n    updateHover: (options: MarkerOptions) => Promise<WrappedMarker>;\n    registerEventCB: (event_type: MarkerEvents, cb: (e?: any) => void) => void;\n    unregisterEventCB: (event_type: MarkerEvents) => void;\n}\n\nexport type AnyObjectOptions = MarkerOptions | PolylineOptions | PolygonOptions;\n\n\nexport type MapObjectType = \"polyline\" | \"polygon\" | \"marker\";\n\n\n\n\nconst CUTTING_SNAP_DISTANCE = 200;\nconst Z_INDEX_SCISSORS = 9001;\nconst Z_INDEX_SCISSORS_HOVER = 9002;\n\nconst PROJECTIONS = {\n    gmaps: '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0.0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs +over',\n    rt90: '+proj=tmerc +lat_0=0 +lon_0=15.80827777777778 +k=1 +x_0=1500000 +y_0=0 +ellps=bessel +towgs84=414.1,41.3,603.1,-0.855,2.141,-7.023,0 +units=m +no_defs',\n    sweref99: '+proj=tmerc +lat_0=0 +lon_0=15.80628452944445 +k=1.00000561024 +x_0=1500064.274 +y_0=-667.711 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',\n};\nproj4.defs('GMAPS', PROJECTIONS.gmaps);\nproj4.defs('RT90', PROJECTIONS.rt90);\nproj4.defs('SWEREF99', PROJECTIONS.sweref99);\n\nexport default class WrappedMapBase extends React.Component<MapBaseProps, any> {\n\n    do_after_init: (() => void)[] = [];\n    do_on_drag_end: (() => void)[] = [];\n    do_on_drag_start: (() => void)[] = [];\n    drawing_completed_listener: google.maps.MapsEventListener | null = null;\n    map: google.maps.Map | null = null;\n    initialized: boolean = false;\n    map_objects: {\n        marker: {\n            [key: string]: WrappedMarker;\n        }\n        polygon: {\n            [key: string]: WrappedPolygon;\n        }\n        polyline: {\n            [key: string]: WrappedPolyline;\n        }\n    } = {\n        marker: {},\n        polygon: {},\n        polyline: {}\n    };\n    cutting_objects: {\n        [key: string]: any;\n        hover_scissors?: any;\n    } = {};\n    overlay: google.maps.OverlayView | null = null;\n    cutting: {\n        enabled: boolean,\n        id: string | null,\n        indexes: number[] | null,\n        arr?: [number, number][]\n    } = {\n        enabled: false,\n        id: null,\n        indexes: null\n    };\n    cutting_completed_listener: ((segments: [number, number][][] | null) => void) | null = null;\n    cancel_drawing: boolean = false;\n    helpers: {\n        rt90: {\n            pointsAroundCircle: makePointsAroundCircleRT90;\n            makeRect: makeRectRT90;\n            arrayRT90ToWGS84: (rt90_array: [number, number][]) => [number, number][];\n            arrayRT90ToWGS84LatLngObj: (rt90_array: [number, number][]) => LatLngLiteral[];\n            movePointsByCoord: movePointsByCoord;\n        };\n        arrToLatLngObj: arrayToLatLngObject;\n        latlngArrayToCoordArray: latLngArrayToCoordArray;\n        convertFromArrayOfArray: convertFromArrayOfArray;\n        haversineDistance: haversineDistance;\n        MVCArrayToCoordArray: MVCArrayToCoordArray;\n        MVCArrayToObjArray: MVCArrayToObjArray;\n    };\n    script_cache: any;\n    html_element: any;\n    services: any;\n\n\n\n\n\n\n\n    constructor(props: MapBaseProps) {\n        super(props);\n\n        this.cutting = {\n            enabled: false,\n            id: null,\n            indexes: null,\n        };\n\n        this.helpers = {\n            rt90: {\n                pointsAroundCircle: external_helpers.makePointsAroundCircleRT90,\n                makeRect: external_helpers.makeRectRT90,\n                arrayRT90ToWGS84: (rt90arr) => { return external_helpers.convertFromArrayOfArray(\"RT90\", \"WGS84\", rt90arr); },\n                arrayRT90ToWGS84LatLngObj: (rt90arr) => { return external_helpers.arrayToLatLngObject(external_helpers.convertFromArrayOfArray(\"RT90\", \"WGS84\", rt90arr), true); },\n                movePointsByCoord: external_helpers.movePointsByCoord\n            },\n            arrToLatLngObj: external_helpers.arrayToLatLngObject,\n            latlngArrayToCoordArray: external_helpers.latLngArrayToCoordArray,\n            convertFromArrayOfArray: external_helpers.convertFromArrayOfArray,\n            haversineDistance: external_helpers.haversineDistance,\n            MVCArrayToCoordArray: external_helpers.MVCArrayToCoordArray,\n            MVCArrayToObjArray: external_helpers.MVCArrayToObjArray\n        };\n    }\n\n    componentWillMount() {\n        this.script_cache = ScriptCache({\n            google: this.props.googleapi_maps_uri\n        });\n    }\n\n    componentWillUnmount() {\n        if (this.map && this.initialized) {\n            window.google.maps.event.clearInstanceListeners(this.map);\n        }\n    }\n\n    componentDidMount() {\n        const refs = this.refs;\n        if (this.props.id) {\n            if (window.hasOwnProperty(\"allbin_gmaps\")) {\n                window.wrapped_gmaps[this.props.id] = this;\n            }\n        }\n        this.script_cache.google.onLoad((err: any) => {\n\n            function CanvasProjectionOverlay() { }\n            CanvasProjectionOverlay.prototype = new window.google.maps.OverlayView();\n            CanvasProjectionOverlay.prototype.constructor = CanvasProjectionOverlay;\n            CanvasProjectionOverlay.prototype.onAdd = function () { };\n            CanvasProjectionOverlay.prototype.draw = function () { };\n            CanvasProjectionOverlay.prototype.onRemove = function () { };\n\n            const mapRef = refs.map;\n            this.html_element = ReactDOM.findDOMNode(mapRef);\n\n            let center = this.props.default_center;\n            if (!center) {\n                throw new Error(\"Could not create map: Requires 'default_center' prop.\");\n            }\n            let zoom = (typeof this.props.default_zoom !== \"undefined\") ? this.props.default_zoom : null;\n            if (!zoom) {\n                throw new Error(\"Could not create map: Requires 'default_zoom' prop.\");\n            }\n            if (!this.props.googleapi_maps_uri) {\n                throw new Error(\"Could not create map: Requires 'googleapi_maps_uri' prop. Ex: https://maps.googleapis.com/maps/api/js?v=3.exp&libraries=geometry,places,drawing&key=XXXXXXXXXX\");\n            }\n            let defaults = this.props.default_options || {};\n            let mapConfig = Object.assign(\n                {},\n                defaults,\n                {\n                center: new window.google.maps.LatLng(center.lat, center.lng),\n                zoom: zoom,\n                gestureHandling: 'greedy',\n                styles: this.props.styles || {}\n            });\n            const maps = window.google.maps;\n\n            this.map = new maps.Map(this.html_element, mapConfig);\n            this.services = {\n                geocoderService: new window.google.maps.Geocoder(),\n                directionsService: new window.google.maps.DirectionsService(),\n            };\n            if (window.google.maps.drawing) {\n                this.services.drawing = window.google.maps.drawing;\n                this.services.drawingManager = new window.google.maps.drawing.DrawingManager({\n                    drawingMode: null,\n                    drawingControl: false,\n                    drawingControlOptions: {\n                        drawingModes: []\n                    }\n                });\n                this.services.drawingManager.setMap(this.map);\n            }\n\n            this.overlay = new (CanvasProjectionOverlay as any)();\n            if (this.overlay) {\n                this.overlay.setMap(this.map);\n            }\n            if (!this.map) {\n                throw new Error(\"Tried to setup events before map instance was defined.\");\n            }\n            this.setupMapEvents(this.map);\n\n            window.google.maps.event.addListenerOnce(this.map, 'idle', () => { this.doAfterInit(); });\n        });\n    }\n\n    doAfterInit(): void {\n        this.initialized = true;\n        this.do_after_init.forEach((cb) => {\n            cb();\n        });\n\n        if (this.props.initializedCB) {\n            //Tell parent we are initialized if the parent has asked for it.\n            this.props.initializedCB(this);\n        }\n    }\n\n    setCenter(latLng: LatLngLiteral | LatLng): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.initialized) {\n                this.do_after_init.push(() => {\n                    this.setCenter(latLng).then((res) => {\n                        resolve(res);\n                    }).catch((err) => {\n                        reject(err);\n                    });\n                });\n                return;\n            }\n            if (this.map) {\n                this.map.setCenter(latLng);\n            }\n            resolve();\n            return;\n        });\n    }\n\n    fitToBoundsArray(arr_of_coords: [number, number][]) {\n        return internal_helpers.fitToBoundsOfArray(this, arr_of_coords);\n    }\n    fitToBoundsObjectArray(arr_of_objects: LatLngLiteral[]) {\n        return internal_helpers.fitToBoundsOfObjectArray(this, arr_of_objects);\n    }\n\n    fromLatLngToPixel(map_ref: WrappedMapBase, latLng: LatLng) {\n        return internal_helpers.fromLatLngToPixel(this, latLng);\n    }\n\n    toPixel(lat_lng_input: LatLng|LatLngLiteral): [number, number] {\n        if (!this.overlay) {\n            throw new Error(\"Overlay not loaded when calling toPixel.\");\n        }\n        let node_rect = this.html_element.getBoundingClientRect();\n        let lat_lng: LatLng;\n        if (lat_lng_input instanceof google.maps.LatLng) {\n            lat_lng = lat_lng_input;\n        } else {\n            lat_lng = new window.google.maps.LatLng(lat_lng_input);\n        }\n        let pixel_obj = this.overlay.getProjection().fromLatLngToContainerPixel(lat_lng);\n        return [pixel_obj.x + node_rect.left, pixel_obj.y + node_rect.top];\n    }\n\n    setZoom(zoom_level: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.initialized) {\n                this.do_after_init.push(() => {\n                    this.setZoom(zoom_level).then((res) => {\n                        resolve(res);\n                    }).catch((err) => {\n                        reject(err);\n                    });\n                });\n                return;\n            }\n            if (this.map) {\n                this.map.setZoom(zoom_level);\n            }\n            resolve();\n            return;\n        });\n    }\n\n    setPolyline(id: string, options: PolylineOptions, hover_options: PolylineOptions | null = null): Promise<WrappedPolyline> {\n        return internal_helpers.setPolyline(this, id, options, hover_options);\n    }\n    unsetPolyline(id: string): Promise<boolean> {\n        return internal_helpers.unsetMapObject(this, \"polyline\", id);\n    }\n    clearPolylines(): Promise<boolean[]> {\n        let promise_arr: Promise<boolean>[] = [];\n        Object.keys(this.map_objects.polyline).forEach((id) => {\n            promise_arr.push(internal_helpers.unsetMapObject(this, \"polyline\", id));\n        });\n        return Promise.all(promise_arr);\n    }\n\n    setPolygon(id: string, options: PolygonOptions, hover_options: PolygonOptions | null = null): Promise<WrappedPolygon> {\n        return internal_helpers.setPolygon(this, id, options, hover_options);\n    }\n    unsetPolygon(id: string): Promise<boolean> {\n        return internal_helpers.unsetMapObject(this, \"polygon\", id);\n    }\n    clearPolygons(): Promise<boolean[]> {\n        let promise_arr: Promise<boolean>[] = [];\n        Object.keys(this.map_objects.polygon).forEach((id) => {\n            promise_arr.push(internal_helpers.unsetMapObject(this, \"polygon\", id));\n        });\n        return Promise.all(promise_arr);\n    }\n\n    setMarker(id: string, options: MarkerOptions, hover_options: MarkerOptions | null = null): Promise<WrappedGmapObj> {\n        return internal_helpers.setMarker(this, id, options, hover_options);\n    }\n    unsetMarker(id: string): Promise<boolean> {\n        return internal_helpers.unsetMapObject(this, \"marker\", id);\n    }\n    clearMarkers(): Promise<boolean[]> {\n        let promise_arr: Promise<boolean>[] = [];\n        Object.keys(this.map_objects.marker).forEach((id) => {\n            promise_arr.push(internal_helpers.unsetMapObject(this, \"marker\", id));\n        });\n        return Promise.all(promise_arr);\n    }\n\n\n    registerDragEndCB(cb: () => void): void {\n        //Is actually triggered by Idle, not DragEnd!\n        this.do_on_drag_end.push(cb);\n    }\n    unregisterDragEndCB(cb: () => void): void {\n        let index = this.do_on_drag_end.indexOf(cb);\n        if (index > -1) {\n            this.do_on_drag_end.splice(index, 1);\n        }\n    }\n    registerDragStartCB(cb: () => void): void {\n        this.do_on_drag_end.push(cb);\n    }\n    unregisterDragStartCB(cb: () => void): void {\n        let index = this.do_on_drag_start.indexOf(cb);\n        if (index > -1) {\n            this.do_on_drag_start.splice(index, 1);\n        }\n    }\n    setupMapEvents(map: google.maps.Map) {\n        map.addListener('center_changed', () => {\n            if (this.props.onCenterChanged) {\n                this.props.onCenterChanged();\n            }\n        });\n        map.addListener('bounds_changed', () => {\n            if (this.props.onBoundsChanged) {\n                this.props.onBoundsChanged();\n            }\n        });\n        map.addListener('click', (mouse_event) => {\n            if (this.cutting.enabled) {\n                this.cuttingClick(mouse_event);\n            }\n            if (this.props.onClick && !this.cutting.enabled) {\n                this.props.onClick(mouse_event);\n            }\n        });\n        map.addListener('dblclick', (mouse_event) => {\n            if (this.props.onDoubleClick && !this.cutting.enabled) {\n                this.props.onDoubleClick(mouse_event);\n            }\n        });\n        map.addListener('drag', () => {\n            if (this.props.onDrag && !this.cutting.enabled) {\n                this.props.onDrag();\n            }\n        });\n        map.addListener('dragend', () => {\n            if (this.props.onDragEnd && !this.cutting.enabled) {\n                this.props.onDragEnd();\n            }\n        });\n        map.addListener('dragstart', () => {\n            this.do_on_drag_start.forEach((cb) => {\n                if (!this.cutting.enabled) {\n                    cb();\n                }\n            });\n            if (this.props.onDragStart && !this.cutting.enabled) {\n                this.props.onDragStart();\n            }\n        });\n        map.addListener('heading_changed', () => {\n            if (this.props.onHeadingChanged) {\n                this.props.onHeadingChanged();\n            }\n        });\n        map.addListener('idle', () => {\n            this.do_on_drag_end.forEach((cb) => {\n                if (!this.cutting.enabled) {\n                    cb();\n                }\n            });\n            if (this.props.onIdle && !this.cutting.enabled) {\n                this.props.onIdle();\n            }\n        });\n        map.addListener('maptypeid_changed', () => {\n            if (this.props.onMapTypeIdChanged) {\n                this.props.onMapTypeIdChanged();\n            }\n        });\n        map.addListener('mousemove', (mouse_event: MouseEvent) => {\n            if (this.cutting.enabled) {\n                this.cuttingPositionUpdate(mouse_event);\n            }\n            if (this.props.onMouseMove) {\n                this.props.onMouseMove(mouse_event);\n            }\n        });\n        map.addListener('mouseout', (mouse_event: MouseEvent) => {\n            if (this.props.onMouseOut) {\n                this.props.onMouseOut(mouse_event);\n            }\n        });\n        map.addListener('mouseover', (mouse_event: MouseEvent) => {\n            if (this.props.onMouseOver) {\n                this.props.onMouseOver(mouse_event);\n            }\n        });\n        map.addListener('projection_changed', () => {\n            if (this.props.onProjectionChanged) {\n                this.props.onProjectionChanged();\n            }\n        });\n        map.addListener('reize', () => {\n            if (this.props.onResize) {\n                this.props.onResize();\n            }\n        });\n        map.addListener('rightclick', (mouse_event: MouseEvent) => {\n            if (this.props.onRightClick && !this.cutting.enabled) {\n                this.props.onRightClick(mouse_event);\n            }\n        });\n        map.addListener('tilesloaded', () => {\n            if (this.props.onTilesLoaded) {\n                this.props.onTilesLoaded();\n            }\n        });\n        map.addListener('tilt_changed', () => {\n            if (this.props.onTiltChanged) {\n                this.props.onTiltChanged();\n            }\n        });\n        map.addListener('zoom_changed', () => {\n            if (this.props.onZoomChanged) {\n                this.props.onZoomChanged();\n            }\n        });\n    }\n\n\n\n\n    setDrawingMode(type: \"polyline\" | \"polygon\", opts: PolylineOptions | PolygonOptions, cb: (path: [number, number][] | [number, number] | null, overlay: Polygon|Polyline|Marker) => void) {\n        let mode = null;\n        if (!this.services.drawing) {\n            console.error(\"MAP: Drawing library not available! Add it to google maps api request url.\");\n            return;\n        }\n        if (this.services.drawing.OverlayType.hasOwnProperty(type.toUpperCase())) {\n            mode = this.services.drawing.OverlayType[type.toUpperCase()];\n        } else {\n            throw new Error(\"MAP: Invalid drawing mode type:\" + type);\n        }\n        let drawing_opts = Object.assign({}, opts, { drawingMode: mode });\n        this.services.drawingManager.setOptions(drawing_opts);\n        console.log(\"MAP: Drawing mode started for:\", type + \".\");\n        this.cancel_drawing = false;\n\n        if (this.drawing_completed_listener) {\n            this.drawing_completed_listener.remove();\n        }\n        this.drawing_completed_listener = google.maps.event.addListenerOnce(\n            this.services.drawingManager,\n            'overlaycomplete',\n            (e: google.maps.drawing.OverlayCompleteEvent) => {\n                // console.log(\"overlay complete\", cb, this.cancel_drawing);\n                e.overlay.setMap(null);\n                drawing_opts.drawingMode = null;\n                this.services.drawingManager.setOptions(drawing_opts);\n                if (!cb || this.cancel_drawing) {\n                    return;\n                }\n                if (type === \"polyline\" || type === \"polygon\") {\n                    const overlay = e.overlay as Polygon | Polyline;\n                    let path = external_helpers.MVCArrayToCoordArray(overlay.getPath());\n                    if (cb) { cb(path as [number, number][], overlay); }\n                } else if (type === \"marker\") {\n                    const overlay = e.overlay as Marker;\n                    let pos = overlay.getPosition();\n                    cb([pos.lat(), pos.lng()], overlay);\n                } else {\n                    cb(null, e.overlay as any);\n                }\n                this.cancel_drawing = false;\n                this.drawing_completed_listener = null;\n            }\n        );\n    }\n    completeDrawingMode() {\n        if (this.services.drawing) {\n            this.services.drawingManager.setOptions({ drawingMode: null });\n        }\n        if (this.drawing_completed_listener) {\n            this.drawing_completed_listener.remove();\n            this.drawing_completed_listener = null;\n        }\n    }\n    cancelDrawingMode(debug_src?: string) {\n        if (debug_src) {\n            console.log(\"cancel drawing mode:\", debug_src);\n        }\n        if (this.services.drawing && this.drawing_completed_listener) {\n            this.cancel_drawing = true;\n            this.services.drawingManager.setOptions({ drawingMode: null });\n        }\n    }\n\n\n\n\n\n    setCuttingMode(polyline_id: string, cb = null) {\n        if (this.map_objects.polyline.hasOwnProperty(polyline_id) === false) {\n            console.error(\"MAP: Cannot set cutting mode, provided object id not on map: \", polyline_id);\n            return;\n        }\n        if (!cb) {\n            console.error(\"MAP: Cannot setCuttingMode without supplying completed callback.\");\n            return;\n        }\n        this.cancelDrawingMode(\"setCuttingMode\");\n        let polyline = this.map_objects.polyline[polyline_id];\n        let opts = {\n            clickable: false,\n            editable: false\n        };\n        polyline.gmaps_obj.setOptions(opts);\n\n        const path = polyline.options.path;\n        this.cutting = {\n            enabled: true,\n            id: polyline_id,\n            indexes: [],\n            arr: path as any\n        };\n        if (!this.cutting_objects.hasOwnProperty(\"hover_scissors\")) {\n            let opts = {\n                position: this.props.default_center,\n                icon: {\n                    url: ScissorHoverIcon\n                },\n                zIndex: Z_INDEX_SCISSORS_HOVER,\n                visible: false,\n                clickable: false,\n                editable: false,\n                draggable: false\n            };\n            let hover_scissors = {\n                gmaps_obj: new window.google.maps.Marker(opts),\n                options: opts\n            };\n            hover_scissors.gmaps_obj.setMap(this.map);\n            this.cutting_objects.hover_scissors = hover_scissors;\n        }\n        console.log(\"MAP: Cutting mode started for id: \" + polyline_id);\n        this.cutting_completed_listener = (value) => {\n            if (cb) {\n                (cb as any)(value);\n            } else {\n                throw new Error(\"Callback for cutting completed not defined.\");\n            }\n        };\n    }\n    cuttingPositionUpdate(mouse_event: MouseEvent) {\n        if (!this.cutting.enabled || !this.cutting.id) {\n            //If we are not in cutting mode ignore this function call.\n            return;\n        }\n        let polyline = this.map_objects.polyline[this.cutting.id];\n        let mouse_coord = { lat: mouse_event.latLng.lat(), lng: mouse_event.latLng.lng() };\n        let closest_index = 0;\n        let closest_dist = 9999999;\n        //Find nearest index and move scissors_hover marker.\n        polyline.options.path!.forEach((point: any, i: number) => {\n            let dist = external_helpers.haversineDistance(mouse_coord, point);\n            if (dist < closest_dist) {\n                closest_index = i;\n                closest_dist = dist;\n            }\n        });\n        let path = polyline.options.path as any;\n        if (closest_dist < CUTTING_SNAP_DISTANCE && closest_index > 0 && closest_index < path.length - 1) {\n            this.cutting_objects.hover_scissors.gmaps_obj.setOptions({\n                position: path[closest_index],\n                visible: true\n            });\n        } else {\n            this.cutting_objects.hover_scissors.gmaps_obj.setOptions({\n                visible: false\n            });\n        }\n    }\n    cuttingClick(mouse_event: google.maps.MouseEvent) {\n        if (!this.cutting.id) {\n            console.error(\"No cutting.id set when clicking for cut.\");\n            return;\n        }\n        if (!this.cutting.indexes) {\n            console.error(\"cutting.indexes not defined when clicking for cut.\");\n            return;\n        }\n        let polyline = this.map_objects.polyline[this.cutting.id];\n        let path = polyline.options.path as any;\n        let mouse_coord = { lat: mouse_event.latLng.lat(), lng: mouse_event.latLng.lng() };\n        let closest_index = 0;\n        let closest_dist = 9999999;\n        path.forEach((point: any, i: number) => {\n            let dist = external_helpers.haversineDistance(mouse_coord, point);\n            if (dist < closest_dist) {\n                closest_index = i;\n                closest_dist = dist;\n            }\n        });\n        if (closest_dist > CUTTING_SNAP_DISTANCE) {\n            //Pointer is too far away from any point, ignore.\n            return;\n        }\n        if (closest_index === 0 || closest_index === path.length - 1) {\n            //We are never interested in first or last point.\n            return;\n        }\n        let already_selected_position = this.cutting.indexes.findIndex(value => closest_index === value);\n        if (already_selected_position > -1) {\n            //This index has already been selected for cutting, remove it.\n            this.cutting.indexes.splice(already_selected_position, 1);\n            if (this.cutting_objects.hasOwnProperty(\"index_\" + closest_index)) {\n                //We have drawn a marker for this cut, remove it.\n                this.cutting_objects[\"index_\" + closest_index].gmaps_obj.setMap(null);\n                delete this.cutting_objects[\"index_\" + closest_index];\n            }\n        } else {\n            this.cutting.indexes.push(closest_index);\n            let opts = {\n                position: path[closest_index],\n                icon: {\n                    url: ScissorIcon\n                },\n                zIndex: Z_INDEX_SCISSORS,\n                visible: true,\n                clickable: false,\n                editable: false,\n                draggable: false\n            };\n            let cut_marker = {\n                gmaps_obj: new window.google.maps.Marker(opts),\n                options: opts\n            };\n            cut_marker.gmaps_obj.setMap(this.map);\n            this.cutting_objects[\"index_\" + closest_index] = cut_marker;\n        }\n    }\n    completeCuttingMode() {\n        if (!this.cutting || this.cutting.id === null) { return; }\n        let indexes = this.cutting.indexes;\n        let polyline = this.map_objects.polyline[this.cutting.id];\n        if (!polyline) { return; }\n        this.cutting = {\n            enabled: false,\n            id: null,\n            indexes: null\n        };\n        Object.keys(this.cutting_objects).forEach((marker_id) => {\n            //Remove all cutting related markers.\n            this.cutting_objects[marker_id].gmaps_obj.setMap(null);\n            delete this.cutting_objects[marker_id];\n        });\n\n\n        let opts = {\n            clickable: true,\n            editable: true\n        };\n        polyline.gmaps_obj.setOptions(opts);\n        if (!indexes || indexes.length === 0) {\n            //We made no selections, just return.\n            if (this.cutting_completed_listener) {\n                this.cutting_completed_listener(null);\n            }\n            return;\n        }\n\n        let path = polyline.options.path as unknown as [number, number][];\n        indexes.sort();\n        //Add last index so that the remaining points form a segment as well.\n        indexes.push(path.length - 1);\n        let resulting_segments: ([number, number][])[] = [];\n        let prev_index = 0;\n        indexes.forEach((index) => {\n            let segment = path.slice(prev_index, index);\n            //Copy last point as well.\n            segment.push(path[index]);\n            resulting_segments.push(segment);\n            prev_index = index;\n        });\n        if (this.cutting_completed_listener) {\n            this.cutting_completed_listener(resulting_segments);\n        }\n    }\n    cancelCuttingMode() {\n        this.cutting = {\n            enabled: false,\n            id: null,\n            indexes: null\n        };\n        Object.keys(this.cutting_objects).forEach((marker_id) => {\n            //Remove all cutting related markers.\n            this.cutting_objects[marker_id].gmaps_obj.setMap(null);\n            delete this.cutting_objects[marker_id];\n        });\n        if (!this.cutting.id) {\n            console.error(\"No cutting.id set when cancelling cutting mode.\");\n            return;\n        }\n        let polyline = this.map_objects.polyline[this.cutting.id];\n        if (polyline) {\n            let opts = {\n                clickable: true,\n                editable: true\n            };\n            polyline.gmaps_obj.setOptions(opts);\n        }\n    }\n\n\n    render() {\n        return (\n            <div style={{ height: \"100%\" }}>\n                <div ref=\"map\" style={{ position:\"absolute\", top: '0', left: '0', right: '0', bottom: '0' }} />\n            </div>\n        );\n    }\n}\n\n\n\n"]}