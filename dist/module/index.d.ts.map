{"version":3,"sources":["../src/module/index.tsx"],"names":[],"mappings":"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","file":"index.d.ts","sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport proj4 from 'proj4';\nimport { Feature, GeoJsonProperties, Geometry, GeoJsonObject } from 'geojson';\n\nimport ScriptCache from './ScriptCache';\nimport { MVCArrayToCoordArray, MVCArrayToObjArray, movePointsByCoord, makePointsAroundCircleRT90, makeRectRT90, convertFromArrayOfArray, arrayToLatLngObject, latLngArrayToCoordArray, haversineDistance, makePointsAroundCircleRT90Type, makeRectRT90Type, movePointsByCoordType, arrayToLatLngObjectType, latLngArrayToCoordArrayType, convertFromArrayOfArrayType, haversineDistanceType, MVCArrayToCoordArrayType, MVCArrayToObjArrayType} from './external_helpers';\nimport * as internal_helpers from './internal_helpers';\nimport * as feature_helpers from './feature_helpers';\nlet ScissorIcon = require('./img/marker_scissors.svg');\nlet ScissorHoverIcon = require('./img/marker_scissors_hover.svg');\n\n\ndeclare global {\n    interface Window {\n        google: any;\n        wrapped_gmaps: any;\n    }\n}\n\nexport interface LatLngLiteral {\n    lat: number;\n    lng: number;\n}\nexport interface LatLngBoundsLiteral {\n    north: number;\n    east: number;\n    south: number;\n    west: number;\n}\nexport interface LatLng extends google.maps.LatLng {}\nexport interface MouseEvent extends google.maps.MouseEvent {}\nexport interface Polyline extends google.maps.Polyline {}\nexport interface PolylineOptions extends google.maps.PolylineOptions {}\n/**\n * Polyline collection must contain a default property.\n * Use Polyline.applyOptions('option_id') to apply one of the defined styles.\n * Use Polyline.setOptions(PolylineOptionsSet) to specify new options.\n */\nexport interface PolylineOptionsSet {\n    default: PolylineOptions;\n    [id: string]: PolylineOptions;\n}\nexport interface Polygon extends google.maps.Polygon {}\nexport interface PolygonOptions extends google.maps.PolygonOptions {}\n/**\n * Polygon collection must contain a default property.\n * Use Polygon.applyOptions('option_id') to apply one of the defined styles.\n * Use Polygon.setOptions(PolygonOptionsSet) to specify new options.\n */\nexport interface PolygonOptionsSet {\n    default: PolygonOptions;\n    [id: string]: PolygonOptions;\n}\nexport interface Marker extends google.maps.Marker {}\nexport interface MarkerOptions extends google.maps.MarkerOptions {}\n/**\n * Marker collection must contain a default property.\n * Use Marker.applyOptions('option_id') to apply one of the defined styles.\n * Use Marker.setOptions(MarkerOptionsSet) to specify new options.\n */\nexport interface MarkerOptionsSet {\n    default: MarkerOptions;\n    [id: string]: MarkerOptions;\n}\n\nexport type AnyObjectOptions = MarkerOptions | PolylineOptions | PolygonOptions;\nexport type AnyObjectOptionsSet = MarkerOptionsSet | PolylineOptionsSet | PolygonOptionsSet;\n\n\nexport interface Feature extends google.maps.Data.Feature {}\nexport interface FeatureOptions extends google.maps.Data.StyleOptions {}\n/**\n * Feature collection must contain a default property.\n * Use Feature.applyOptions('option_id') to apply one of the defined styles.\n * Use Feature.setOptions(PolylineOptionsSet) to specify new options.\n */\nexport interface FeatureOptionsSet {\n    default: FeatureOptions;\n    [id: string]: FeatureOptions;\n}\n\n\n\nexport type MarkerEvents = \"click\" | \"mouseover\" | \"mouseout\" | \"mousedown\" | \"mouseup\" | \"dragstart\" | \"drag\" | \"dragend\" | \"dblclick\" | \"rightclick\";\nexport type PolylineEvents = \"click\" | \"dblclick\" | \"dragstart\" | \"drag\" | \"dragend\" | \"mouseover\" | \"mouseout\" | \"mousedown\" | \"mouseup\" | \"mousemove\" | \"rightclick\" | \"set_at\" | \"remove_at\" | \"insert_at\";\nexport type PolygonEvents = \"click\" | \"dblclick\" | \"dragstart\" | \"drag\" | \"dragend\" | \"mouseover\" | \"mouseout\" | \"mousedown\" | \"mouseup\" | \"mousemove\" | \"rightclick\" | \"set_at\" | \"remove_at\" | \"insert_at\";\nexport type AllMapObjEvents = MarkerEvents | PolylineEvents | PolygonEvents;\nexport type FeatureEvents = \"click\" | \"mouseover\" | \"mouseout\" | \"mousedown\" | \"mouseup\" | \"rightclick\";\nexport interface MapBaseProps {\n    initializedCB?: (this_ref: WrappedMapBase) => void;\n    googleapi_maps_uri: string;\n    id?: string;\n    default_center: LatLngLiteral;\n    default_zoom: number;\n    default_options?: object;\n    onCenterChanged?: () => void;\n    onBoundsChanged?: () => void;\n    onClick?: (e: any) => void;\n    onDoubleClick?: (e: any) => void;\n    onDrag?: () => void;\n    onDragEnd?: () => void;\n    onDragStart?: () => void;\n    onHeadingChanged?: () => void;\n    onIdle?: () => void;\n    onMapTypeIdChanged?: () => void;\n    onMouseMove?: (e: any) => void;\n    onMouseOut?: (e: any) => void;\n    onMouseOver?: (e: any) => void;\n    onProjectionChanged?: () => void;\n    onResize?: () => void;\n    onRightClick?: (e: any) => void;\n    onTilesLoaded?: () => void;\n    onTiltChanged?: () => void;\n    onZoomChanged?: () => void;\n    styles?: object;\n}\n\nexport interface WrappedGmapObj {\n    gmaps_obj?: any;\n    type: MapObjectType;\n    show: () => void;\n    hide: () => void;\n    remove: () => void;\n    /** **Do not modify this property**.\n     *\n     * It is used internally to track event callbacks.\n     * */\n    _cbs: {\n        [key: string]: (e?: any) => void;\n    };\n    registerEventCB: (event_type: MarkerEvents & PolygonEvents & PolylineEvents, cb: (e?: any) => void) => void;\n    unregisterEventCB: (event_type: MarkerEvents & PolygonEvents & PolylineEvents) => void;\n    options: any;\n    selected_options_id: string;\n    setOptions: (options: any) => Promise<WrappedGmapObj>;\n    applyOptions: (options_id: string) => void;\n    zoomTo: () => void;\n    panTo: () => void;\n}\n\nexport interface WrappedPolygon extends WrappedGmapObj {\n    gmaps_obj: Polygon;\n    type: \"polygon\";\n    options: PolygonOptionsSet;\n    setOptions: (options: PolygonOptionsSet) => Promise<WrappedPolygon>;\n    applyOptions: (options_id: string) => void;\n    registerEventCB: (event_type: PolygonEvents, cb: (e?: any) => void) => void;\n    unregisterEventCB: (event_type: PolygonEvents) => void;\n}\nexport interface WrappedPolyline extends WrappedGmapObj {\n    gmaps_obj: Polyline;\n    type: \"polyline\";\n    options: PolylineOptionsSet;\n    setOptions: (options: PolylineOptionsSet) => Promise<WrappedPolyline>;\n    registerEventCB: (event_type: PolylineEvents, cb: (e?: any) => void) => void;\n    unregisterEventCB: (event_type: PolylineEvents) => void;\n}\nexport interface WrappedMarker extends WrappedGmapObj {\n    gmaps_obj: Marker;\n    type: \"marker\";\n    options: MarkerOptionsSet;\n    setOptions: (options: MarkerOptionsSet) => Promise<WrappedMarker>;\n    registerEventCB: (event_type: MarkerEvents, cb: (e?: any) => void) => void;\n    unregisterEventCB: (event_type: MarkerEvents) => void;\n}\nexport interface WrappedFeature {\n    gmaps_feature: google.maps.Data.Feature;\n    options: FeatureOptionsSet;\n    /** **Do not modify this property**\n     *\n     * It is used internally to track visibility state of the feature.\n     * */\n    _visible: boolean;\n    /** **Do not modify this property**\n     *\n     * It is used internally to track event callbacks.\n     * */\n    _cbs: { [key: string]: (e: google.maps.Data.MouseEvent) => void };\n    /** **Do not modify this property**.\n     *\n     * It is used internally for panTo and zoomTo operations.\n     * */\n    _bbox: google.maps.LatLngBounds;\n    selected_options_id: string;\n    show: () => void;\n    hide: () => void;\n    remove: () => void;\n    setOptions: (options: FeatureOptionsSet) => Promise<WrappedFeature>;\n    applyOptions: (options_id: string) => void;\n    registerEventCB: (event_type: FeatureEvents, cb: (e: google.maps.Data.MouseEvent) => void) => void;\n    unregisterEventCB: (event_type: FeatureEvents) => void;\n    zoomTo: () => void;\n    panTo: () => void;\n}\n\nexport type MapObjectType = \"polyline\" | \"polygon\" | \"marker\";\n\n\nexport interface GeoJSONFeature<G extends Geometry | null = Geometry, P extends GeoJsonProperties = null> extends Feature<G, P> {\n    id: string | number;\n}\n\nexport interface GeoJSONFeatureCollection<G extends Geometry | null = Geometry, P = GeoJsonProperties> extends GeoJsonObject {\n    type: \"FeatureCollection\";\n    features: Array<GeoJSONFeature<G, P>>;\n}\n\n\nconst CUTTING_SNAP_DISTANCE = 200;\nconst Z_INDEX_SCISSORS = 9001;\nconst Z_INDEX_SCISSORS_HOVER = 9002;\n\nconst PROJECTIONS = {\n    gmaps: '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0.0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs +over',\n    rt90: '+proj=tmerc +lat_0=0 +lon_0=15.80827777777778 +k=1 +x_0=1500000 +y_0=0 +ellps=bessel +towgs84=414.1,41.3,603.1,-0.855,2.141,-7.023,0 +units=m +no_defs',\n    sweref99: '+proj=tmerc +lat_0=0 +lon_0=15.80628452944445 +k=1.00000561024 +x_0=1500064.274 +y_0=-667.711 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs',\n};\nproj4.defs('GMAPS', PROJECTIONS.gmaps);\nproj4.defs('RT90', PROJECTIONS.rt90);\nproj4.defs('SWEREF99', PROJECTIONS.sweref99);\n\n\n\nexport { makePointsAroundCircleRT90 as pointsAroundCircle };\nexport { makeRectRT90 };\nconst arrayRT90ToWGS84 = (rt90arr: [number, number][]) => { return convertFromArrayOfArray(\"RT90\", \"WGS84\", rt90arr); };\nexport { arrayRT90ToWGS84 };\nconst arrayRT90ToWGS84LatLngObj = (rt90arr: [number, number][]) => { return arrayToLatLngObject(convertFromArrayOfArray(\"RT90\", \"WGS84\", rt90arr), true); };\nexport {arrayRT90ToWGS84LatLngObj };\nexport { movePointsByCoord as movePointsByCoord };\nexport { arrayToLatLngObject as arrToLatLngObj };\nexport { latLngArrayToCoordArray };\nexport { convertFromArrayOfArray as convertFromArrayOfCoords };\nexport { haversineDistance };\nexport { MVCArrayToCoordArray };\nexport { MVCArrayToObjArray };\n\n\nexport default class WrappedMapBase extends React.Component<MapBaseProps, any> {\n\n    do_after_init: (() => void)[] = [];\n    do_on_drag_end: (() => void)[] = [];\n    do_on_drag_start: (() => void)[] = [];\n    drawing_completed_listener: google.maps.MapsEventListener | null = null;\n    map: google.maps.Map | null = null;\n    features_layer: google.maps.Data | null = null;\n    feature_layers: google.maps.Data[] = [];\n    initialized: boolean = false;\n    map_objects: {\n        marker: {\n            [id: string]: WrappedMarker;\n            [id: number]: WrappedMarker;\n        }\n        polygon: {\n            [id: string]: WrappedPolygon;\n            [id: number]: WrappedPolygon;\n        }\n        polyline: {\n            [id: string]: WrappedPolyline;\n            [id: number]: WrappedPolyline;\n        }\n        features: {\n            [id: string]: WrappedFeature;\n            [id: number]: WrappedFeature;\n        }\n    } = {\n        marker: {},\n        polygon: {},\n        polyline: {},\n        features: {}\n    };\n    cutting_objects: {\n        [key: string]: any;\n        hover_scissors?: any;\n    } = {};\n    overlay: google.maps.OverlayView | null = null;\n    cutting: {\n        enabled: boolean,\n        id: string | number | null,\n        indexes: number[] | null,\n        arr?: [number, number][]\n    } = {\n        enabled: false,\n        id: null,\n        indexes: null\n    };\n    cutting_completed_listener: ((segments: [number, number][][] | null) => void) | null = null;\n    cancel_drawing: boolean = false;\n    helpers: {\n        rt90: {\n            pointsAroundCircle: makePointsAroundCircleRT90Type;\n            makeRect: makeRectRT90Type;\n            arrayRT90ToWGS84: (rt90_array: [number, number][]) => [number, number][];\n            arrayRT90ToWGS84LatLngObj: (rt90_array: [number, number][]) => LatLngLiteral[];\n            movePointsByCoord: movePointsByCoordType;\n        };\n        arrToLatLngObj: arrayToLatLngObjectType;\n        latlngArrayToCoordArray: latLngArrayToCoordArrayType;\n        convertFromArrayOfArray: convertFromArrayOfArrayType;\n        haversineDistance: haversineDistanceType;\n        MVCArrayToCoordArray: MVCArrayToCoordArrayType;\n        MVCArrayToObjArray: MVCArrayToObjArrayType;\n    };\n    script_cache: any;\n    html_element: any;\n    services: any;\n\n\n\n\n\n\n\n    constructor(props: MapBaseProps) {\n        super(props);\n\n        this.cutting = {\n            enabled: false,\n            id: null,\n            indexes: null,\n        };\n\n        this.helpers = {\n            rt90: {\n                pointsAroundCircle: makePointsAroundCircleRT90,\n                makeRect: makeRectRT90,\n                arrayRT90ToWGS84: (rt90arr) => { return convertFromArrayOfArray(\"RT90\", \"WGS84\", rt90arr); },\n                arrayRT90ToWGS84LatLngObj: (rt90arr) => { return arrayToLatLngObject(convertFromArrayOfArray(\"RT90\", \"WGS84\", rt90arr), true); },\n                movePointsByCoord: movePointsByCoord\n            },\n            arrToLatLngObj: arrayToLatLngObject,\n            latlngArrayToCoordArray: latLngArrayToCoordArray,\n            convertFromArrayOfArray: convertFromArrayOfArray,\n            haversineDistance: haversineDistance,\n            MVCArrayToCoordArray: MVCArrayToCoordArray,\n            MVCArrayToObjArray: MVCArrayToObjArray\n        };\n    }\n\n    componentWillMount() {\n        this.script_cache = ScriptCache({\n            google: this.props.googleapi_maps_uri\n        });\n    }\n\n    componentWillUnmount() {\n        if (this.map && this.initialized) {\n            window.google.maps.event.clearInstanceListeners(this.map);\n        }\n    }\n\n    componentDidMount() {\n        const refs = this.refs;\n        if (this.props.id) {\n            if (window.hasOwnProperty(\"allbin_gmaps\")) {\n                window.wrapped_gmaps[this.props.id] = this;\n            }\n        }\n        this.script_cache.google.onLoad((err: any) => {\n\n            function CanvasProjectionOverlay() { }\n            CanvasProjectionOverlay.prototype = new window.google.maps.OverlayView();\n            CanvasProjectionOverlay.prototype.constructor = CanvasProjectionOverlay;\n            CanvasProjectionOverlay.prototype.onAdd = function () { };\n            CanvasProjectionOverlay.prototype.draw = function () { };\n            CanvasProjectionOverlay.prototype.onRemove = function () { };\n\n            const mapRef = refs.map;\n            this.html_element = ReactDOM.findDOMNode(mapRef);\n\n            let center = this.props.default_center;\n            if (!center) {\n                throw new Error(\"Could not create map: Requires 'default_center' prop.\");\n            }\n            let zoom = (typeof this.props.default_zoom !== \"undefined\") ? this.props.default_zoom : null;\n            if (!zoom) {\n                throw new Error(\"Could not create map: Requires 'default_zoom' prop.\");\n            }\n            if (!this.props.googleapi_maps_uri) {\n                throw new Error(\"Could not create map: Requires 'googleapi_maps_uri' prop. Ex: https://maps.googleapis.com/maps/api/js?v=3.exp&libraries=geometry,places,drawing&key=XXXXXXXXXX\");\n            }\n            let defaults = this.props.default_options || {};\n            let mapConfig = Object.assign(\n                {},\n                defaults,\n                {\n                center: new window.google.maps.LatLng(center.lat, center.lng),\n                zoom: zoom,\n                gestureHandling: 'greedy',\n                styles: this.props.styles || {}\n            });\n            const maps = window.google.maps;\n\n            this.map = new maps.Map(this.html_element, mapConfig);\n            this.features_layer = new maps.Data();\n            if (this.features_layer) {\n                this.features_layer.setMap(this.map);\n                feature_helpers.setupLayerEvents(this, this.features_layer);\n            }\n            this.services = {\n                geocoderService: new window.google.maps.Geocoder(),\n                directionsService: new window.google.maps.DirectionsService(),\n            };\n            if (window.google.maps.drawing) {\n                this.services.drawing = window.google.maps.drawing;\n                this.services.drawingManager = new window.google.maps.drawing.DrawingManager({\n                    drawingMode: null,\n                    drawingControl: false,\n                    drawingControlOptions: {\n                        drawingModes: []\n                    }\n                });\n                this.services.drawingManager.setMap(this.map);\n            }\n\n            this.overlay = new (CanvasProjectionOverlay as any)();\n            if (this.overlay) {\n                this.overlay.setMap(this.map);\n            }\n            if (!this.map) {\n                throw new Error(\"Tried to setup events before map instance was defined.\");\n            }\n            this.setupMapEvents(this.map);\n\n            window.google.maps.event.addListenerOnce(this.map, 'idle', () => { this.doAfterInit(); });\n        });\n    }\n\n    doAfterInit(): void {\n        this.initialized = true;\n        this.do_after_init.forEach((cb) => {\n            cb();\n        });\n\n        if (this.props.initializedCB) {\n            //Tell parent we are initialized if the parent has asked for it.\n            this.props.initializedCB(this);\n        }\n    }\n\n    getBoundsLiteral(): LatLngBoundsLiteral | null {\n        if (!this.map) {\n            return null;\n        }\n        const bounds = this.map.getBounds();\n        if (!bounds) {\n            return null;\n        }\n        const ne = bounds.getNorthEast();\n        const sw = bounds.getSouthWest();\n        return {\n            north: ne.lat(),\n            east: ne.lng(),\n            south: sw.lat(),\n            west: sw.lng()\n        }\n    }\n\n    setCenter(latLng: LatLngLiteral | LatLng): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.initialized) {\n                this.do_after_init.push(() => {\n                    this.setCenter(latLng).then((res) => {\n                        resolve(res);\n                    }).catch((err) => {\n                        reject(err);\n                    });\n                });\n                return;\n            }\n            if (this.map) {\n                this.map.setCenter(latLng);\n            }\n            resolve();\n            return;\n        });\n    }\n\n    fitToBoundsArray(arr_of_coords: [number, number][]) {\n        return internal_helpers.fitToBoundsOfArray(this, arr_of_coords);\n    }\n    fitToBoundsLiteral(bounds: LatLngBoundsLiteral) {\n        return internal_helpers.fitToBoundsLiteral(this, bounds);\n    }\n    fitToBoundsObjectArray(arr_of_objects: LatLngLiteral[]) {\n        return internal_helpers.fitToBoundsOfObjectArray(this, arr_of_objects);\n    }\n\n    fromLatLngToPixel(map_ref: WrappedMapBase, latLng: LatLng) {\n        return internal_helpers.fromLatLngToPixel(this, latLng);\n    }\n\n    toPixel(lat_lng_input: LatLng|LatLngLiteral): [number, number] {\n        if (!this.overlay) {\n            throw new Error(\"Overlay not loaded when calling toPixel.\");\n        }\n        let node_rect = this.html_element.getBoundingClientRect();\n        let lat_lng: LatLng;\n        if (lat_lng_input instanceof google.maps.LatLng) {\n            lat_lng = lat_lng_input;\n        } else {\n            lat_lng = new window.google.maps.LatLng(lat_lng_input);\n        }\n        let pixel_obj = this.overlay.getProjection().fromLatLngToContainerPixel(lat_lng);\n        return [pixel_obj.x + node_rect.left, pixel_obj.y + node_rect.top];\n    }\n\n    setZoom(zoom_level: number): Promise<void> {\n        return new Promise((resolve, reject) => {\n            if (!this.initialized) {\n                this.do_after_init.push(() => {\n                    this.setZoom(zoom_level).then((res) => {\n                        resolve(res);\n                    }).catch((err) => {\n                        reject(err);\n                    });\n                });\n                return;\n            }\n            if (this.map) {\n                this.map.setZoom(zoom_level);\n            }\n            resolve();\n            return;\n        });\n    }\n\n    setPolyline(id: string | number, options: PolylineOptionsSet): Promise<WrappedPolyline> {\n        return internal_helpers.setPolyline(this, id, options);\n    }\n    unsetPolyline(id: string | number): Promise<boolean> {\n        return internal_helpers.unsetMapObject(this, \"polyline\", id);\n    }\n    clearPolylines(): Promise<boolean[]> {\n        let promise_arr: Promise<boolean>[] = [];\n        Object.keys(this.map_objects.polyline).forEach((id) => {\n            promise_arr.push(internal_helpers.unsetMapObject(this, \"polyline\", id));\n        });\n        return Promise.all(promise_arr);\n    }\n\n    setPolygon(id: string | number, options: PolygonOptionsSet): Promise<WrappedPolygon> {\n        return internal_helpers.setPolygon(this, id, options);\n    }\n    unsetPolygon(id: string | number): Promise<boolean> {\n        return internal_helpers.unsetMapObject(this, \"polygon\", id);\n    }\n    clearPolygons(): Promise<boolean[]> {\n        let promise_arr: Promise<boolean>[] = [];\n        Object.keys(this.map_objects.polygon).forEach((id) => {\n            promise_arr.push(internal_helpers.unsetMapObject(this, \"polygon\", id));\n        });\n        return Promise.all(promise_arr);\n    }\n\n    setMarker(id: string | number, options: MarkerOptionsSet): Promise<WrappedMarker> {\n        return internal_helpers.setMarker(this, id, options);\n    }\n    unsetMarker(id: string | number): Promise<boolean> {\n        return internal_helpers.unsetMapObject(this, \"marker\", id);\n    }\n    clearMarkers(): Promise<boolean[]> {\n        let promise_arr: Promise<boolean>[] = [];\n        Object.keys(this.map_objects.marker).forEach((id) => {\n            promise_arr.push(internal_helpers.unsetMapObject(this, \"marker\", id));\n        });\n        return Promise.all(promise_arr);\n    }\n\n    setGeoJSONCollection(collection: GeoJSONFeatureCollection, options: FeatureOptionsSet) {\n        return feature_helpers.setGeoJSONCollection(this, collection, options);\n    }\n    setGeoJSONFeature(feature: GeoJSONFeature, options: FeatureOptionsSet) {\n        return feature_helpers.setGeoJSONFeature(this, feature, options);\n    }\n    clearFeatureCollections() {\n        this.feature_layers.forEach(x => x.setMap(null));\n        this.feature_layers = [];\n        if (this.features_layer) {\n            Object.keys(this.map_objects.features).forEach((feature_key) => {\n                this.map_objects.features[feature_key].remove();\n            });\n        }\n    }\n\n    zoomToObject(item: WrappedMarker | WrappedPolygon | WrappedPolyline | WrappedFeature) {\n        internal_helpers.panZoomToObjectOrFeature(this, item, true);\n    }\n    panToObject(item: WrappedMarker | WrappedPolygon | WrappedPolyline | WrappedFeature) {\n        internal_helpers.panZoomToObjectOrFeature(this, item, false);\n    }\n\n    registerDragEndCB(cb: () => void): void {\n        //Is actually triggered by Idle, not DragEnd!\n        this.do_on_drag_end.push(cb);\n    }\n    unregisterDragEndCB(cb: () => void): void {\n        let index = this.do_on_drag_end.indexOf(cb);\n        if (index > -1) {\n            this.do_on_drag_end.splice(index, 1);\n        }\n    }\n    registerDragStartCB(cb: () => void): void {\n        this.do_on_drag_end.push(cb);\n    }\n    unregisterDragStartCB(cb: () => void): void {\n        let index = this.do_on_drag_start.indexOf(cb);\n        if (index > -1) {\n            this.do_on_drag_start.splice(index, 1);\n        }\n    }\n    setupMapEvents(map: google.maps.Map) {\n        map.addListener('center_changed', () => {\n            if (this.props.onCenterChanged) {\n                this.props.onCenterChanged();\n            }\n        });\n        map.addListener('bounds_changed', () => {\n            if (this.props.onBoundsChanged) {\n                this.props.onBoundsChanged();\n            }\n        });\n        map.addListener('click', (mouse_event) => {\n            if (this.cutting.enabled) {\n                this.cuttingClick(mouse_event);\n            }\n            if (this.props.onClick && !this.cutting.enabled) {\n                this.props.onClick(mouse_event);\n            }\n        });\n        map.addListener('dblclick', (mouse_event) => {\n            if (this.props.onDoubleClick && !this.cutting.enabled) {\n                this.props.onDoubleClick(mouse_event);\n            }\n        });\n        map.addListener('drag', () => {\n            if (this.props.onDrag && !this.cutting.enabled) {\n                this.props.onDrag();\n            }\n        });\n        map.addListener('dragend', () => {\n            if (this.props.onDragEnd && !this.cutting.enabled) {\n                this.props.onDragEnd();\n            }\n        });\n        map.addListener('dragstart', () => {\n            this.do_on_drag_start.forEach((cb) => {\n                if (!this.cutting.enabled) {\n                    cb();\n                }\n            });\n            if (this.props.onDragStart && !this.cutting.enabled) {\n                this.props.onDragStart();\n            }\n        });\n        map.addListener('heading_changed', () => {\n            if (this.props.onHeadingChanged) {\n                this.props.onHeadingChanged();\n            }\n        });\n        map.addListener('idle', () => {\n            this.do_on_drag_end.forEach((cb) => {\n                if (!this.cutting.enabled) {\n                    cb();\n                }\n            });\n            if (this.props.onIdle && !this.cutting.enabled) {\n                this.props.onIdle();\n            }\n        });\n        map.addListener('maptypeid_changed', () => {\n            if (this.props.onMapTypeIdChanged) {\n                this.props.onMapTypeIdChanged();\n            }\n        });\n        map.addListener('mousemove', (mouse_event: MouseEvent) => {\n            if (this.cutting.enabled) {\n                this.cuttingPositionUpdate(mouse_event);\n            }\n            if (this.props.onMouseMove) {\n                this.props.onMouseMove(mouse_event);\n            }\n        });\n        map.addListener('mouseout', (mouse_event: MouseEvent) => {\n            if (this.props.onMouseOut) {\n                this.props.onMouseOut(mouse_event);\n            }\n        });\n        map.addListener('mouseover', (mouse_event: MouseEvent) => {\n            if (this.props.onMouseOver) {\n                this.props.onMouseOver(mouse_event);\n            }\n        });\n        map.addListener('projection_changed', () => {\n            if (this.props.onProjectionChanged) {\n                this.props.onProjectionChanged();\n            }\n        });\n        map.addListener('reize', () => {\n            if (this.props.onResize) {\n                this.props.onResize();\n            }\n        });\n        map.addListener('rightclick', (mouse_event: MouseEvent) => {\n            if (this.props.onRightClick && !this.cutting.enabled) {\n                this.props.onRightClick(mouse_event);\n            }\n        });\n        map.addListener('tilesloaded', () => {\n            if (this.props.onTilesLoaded) {\n                this.props.onTilesLoaded();\n            }\n        });\n        map.addListener('tilt_changed', () => {\n            if (this.props.onTiltChanged) {\n                this.props.onTiltChanged();\n            }\n        });\n        map.addListener('zoom_changed', () => {\n            if (this.props.onZoomChanged) {\n                this.props.onZoomChanged();\n            }\n        });\n    }\n\n\n\n\n    setDrawingMode(type: \"polyline\" | \"polygon\", opts: PolylineOptions | PolygonOptions, cb: (path: [number, number][] | [number, number] | null, overlay: Polygon|Polyline|Marker) => void) {\n        let mode = null;\n        if (!this.services.drawing) {\n            console.error(\"MAP: Drawing library not available! Add it to google maps api request url.\");\n            return;\n        }\n        if (this.services.drawing.OverlayType.hasOwnProperty(type.toUpperCase())) {\n            mode = this.services.drawing.OverlayType[type.toUpperCase()];\n        } else {\n            throw new Error(\"MAP: Invalid drawing mode type:\" + type);\n        }\n        let drawing_opts = Object.assign({}, opts, { drawingMode: mode });\n        this.services.drawingManager.setOptions(drawing_opts);\n        console.log(\"MAP: Drawing mode started for:\", type + \".\");\n        this.cancel_drawing = false;\n\n        if (this.drawing_completed_listener) {\n            this.drawing_completed_listener.remove();\n        }\n        this.drawing_completed_listener = google.maps.event.addListenerOnce(\n            this.services.drawingManager,\n            'overlaycomplete',\n            (e: google.maps.drawing.OverlayCompleteEvent) => {\n                // console.log(\"overlay complete\", cb, this.cancel_drawing);\n                e.overlay.setMap(null);\n                drawing_opts.drawingMode = null;\n                this.services.drawingManager.setOptions(drawing_opts);\n                if (!cb || this.cancel_drawing) {\n                    return;\n                }\n                if (type === \"polyline\" || type === \"polygon\") {\n                    const overlay = e.overlay as Polygon | Polyline;\n                    let path = MVCArrayToCoordArray(overlay.getPath());\n                    if (cb) { cb(path as [number, number][], overlay); }\n                } else if (type === \"marker\") {\n                    const overlay = e.overlay as Marker;\n                    let pos = overlay.getPosition();\n                    cb([pos.lat(), pos.lng()], overlay);\n                } else {\n                    cb(null, e.overlay as any);\n                }\n                this.cancel_drawing = false;\n                this.drawing_completed_listener = null;\n            }\n        );\n    }\n    completeDrawingMode() {\n        if (this.services.drawing) {\n            this.services.drawingManager.setOptions({ drawingMode: null });\n        }\n        if (this.drawing_completed_listener) {\n            this.drawing_completed_listener.remove();\n            this.drawing_completed_listener = null;\n        }\n    }\n    cancelDrawingMode(debug_src?: string) {\n        if (debug_src) {\n            console.log(\"cancel drawing mode:\", debug_src);\n        }\n        if (this.services.drawing && this.drawing_completed_listener) {\n            this.cancel_drawing = true;\n            this.services.drawingManager.setOptions({ drawingMode: null });\n        }\n    }\n\n\n\n\n\n    setCuttingMode(polyline_id: string | number, cb = null) {\n        if (this.map_objects.polyline.hasOwnProperty(polyline_id) === false) {\n            console.error(\"MAP: Cannot set cutting mode, provided object id not on map: \", polyline_id);\n            return;\n        }\n        if (!cb) {\n            console.error(\"MAP: Cannot setCuttingMode without supplying completed callback.\");\n            return;\n        }\n        this.cancelDrawingMode(\"setCuttingMode\");\n        let polyline = this.map_objects.polyline[polyline_id];\n        let opts = {\n            clickable: false,\n            editable: false\n        };\n        polyline.gmaps_obj.setOptions(opts);\n\n        const path = polyline.options.path;\n        this.cutting = {\n            enabled: true,\n            id: polyline_id,\n            indexes: [],\n            arr: path as any\n        };\n        if (!this.cutting_objects.hasOwnProperty(\"hover_scissors\")) {\n            let opts = {\n                position: this.props.default_center,\n                icon: {\n                    url: ScissorHoverIcon\n                },\n                zIndex: Z_INDEX_SCISSORS_HOVER,\n                visible: false,\n                clickable: false,\n                editable: false,\n                draggable: false\n            };\n            let hover_scissors = {\n                gmaps_obj: new window.google.maps.Marker(opts),\n                options: opts\n            };\n            hover_scissors.gmaps_obj.setMap(this.map);\n            this.cutting_objects.hover_scissors = hover_scissors;\n        }\n        console.log(\"MAP: Cutting mode started for id: \" + polyline_id);\n        this.cutting_completed_listener = (value) => {\n            if (cb) {\n                (cb as any)(value);\n            } else {\n                throw new Error(\"Callback for cutting completed not defined.\");\n            }\n        };\n    }\n    cuttingPositionUpdate(mouse_event: MouseEvent) {\n        if (!this.cutting.enabled || !this.cutting.id) {\n            //If we are not in cutting mode ignore this function call.\n            return;\n        }\n        let polyline = this.map_objects.polyline[this.cutting.id];\n        let mouse_coord = { lat: mouse_event.latLng.lat(), lng: mouse_event.latLng.lng() };\n        let closest_index = 0;\n        let closest_dist = 9999999;\n        //Find nearest index and move scissors_hover marker.\n        polyline.gmaps_obj.getPath().forEach((point, i: number) => {\n            let dist = haversineDistance(mouse_coord, { lat: point.lat(), lng: point.lng() });\n            if (dist < closest_dist) {\n                closest_index = i;\n                closest_dist = dist;\n            }\n        });\n        let path = polyline.gmaps_obj.getPath().getArray();\n        if (closest_dist < CUTTING_SNAP_DISTANCE && closest_index > 0 && closest_index < path.length - 1) {\n            this.cutting_objects.hover_scissors.gmaps_obj.setOptions({\n                position: { lat: path[closest_index].lat(), lng: path[closest_index].lng() },\n                visible: true\n            });\n        } else {\n            this.cutting_objects.hover_scissors.gmaps_obj.setOptions({\n                visible: false\n            });\n        }\n    }\n    cuttingClick(mouse_event: google.maps.MouseEvent) {\n        if (!this.cutting.id) {\n            console.error(\"No cutting.id set when clicking for cut.\");\n            return;\n        }\n        if (!this.cutting.indexes) {\n            console.error(\"cutting.indexes not defined when clicking for cut.\");\n            return;\n        }\n        let polyline = this.map_objects.polyline[this.cutting.id];\n        let path = polyline.options.path as any;\n        let mouse_coord = { lat: mouse_event.latLng.lat(), lng: mouse_event.latLng.lng() };\n        let closest_index = 0;\n        let closest_dist = 9999999;\n        path.forEach((point: any, i: number) => {\n            let dist = haversineDistance(mouse_coord, point);\n            if (dist < closest_dist) {\n                closest_index = i;\n                closest_dist = dist;\n            }\n        });\n        if (closest_dist > CUTTING_SNAP_DISTANCE) {\n            //Pointer is too far away from any point, ignore.\n            return;\n        }\n        if (closest_index === 0 || closest_index === path.length - 1) {\n            //We are never interested in first or last point.\n            return;\n        }\n        let already_selected_position = this.cutting.indexes.findIndex(value => closest_index === value);\n        if (already_selected_position > -1) {\n            //This index has already been selected for cutting, remove it.\n            this.cutting.indexes.splice(already_selected_position, 1);\n            if (this.cutting_objects.hasOwnProperty(\"index_\" + closest_index)) {\n                //We have drawn a marker for this cut, remove it.\n                this.cutting_objects[\"index_\" + closest_index].gmaps_obj.setMap(null);\n                delete this.cutting_objects[\"index_\" + closest_index];\n            }\n        } else {\n            this.cutting.indexes.push(closest_index);\n            let opts = {\n                position: path[closest_index],\n                icon: {\n                    url: ScissorIcon\n                },\n                zIndex: Z_INDEX_SCISSORS,\n                visible: true,\n                clickable: false,\n                editable: false,\n                draggable: false\n            };\n            let cut_marker = {\n                gmaps_obj: new window.google.maps.Marker(opts),\n                options: opts\n            };\n            cut_marker.gmaps_obj.setMap(this.map);\n            this.cutting_objects[\"index_\" + closest_index] = cut_marker;\n        }\n    }\n    completeCuttingMode() {\n        if (!this.cutting || this.cutting.id === null) { return; }\n        let indexes = this.cutting.indexes;\n        let polyline = this.map_objects.polyline[this.cutting.id];\n        if (!polyline) { return; }\n        this.cutting = {\n            enabled: false,\n            id: null,\n            indexes: null\n        };\n        Object.keys(this.cutting_objects).forEach((marker_id) => {\n            //Remove all cutting related markers.\n            this.cutting_objects[marker_id].gmaps_obj.setMap(null);\n            delete this.cutting_objects[marker_id];\n        });\n\n\n        let opts = {\n            clickable: true,\n            editable: true\n        };\n        polyline.gmaps_obj.setOptions(opts);\n        if (!indexes || indexes.length === 0) {\n            //We made no selections, just return.\n            if (this.cutting_completed_listener) {\n                this.cutting_completed_listener(null);\n            }\n            return;\n        }\n\n        let path = polyline.options.path as unknown as [number, number][];\n        indexes.sort();\n        //Add last index so that the remaining points form a segment as well.\n        indexes.push(path.length - 1);\n        let resulting_segments: ([number, number][])[] = [];\n        let prev_index = 0;\n        indexes.forEach((index) => {\n            let segment = path.slice(prev_index, index);\n            //Copy last point as well.\n            segment.push(path[index]);\n            resulting_segments.push(segment);\n            prev_index = index;\n        });\n        if (this.cutting_completed_listener) {\n            this.cutting_completed_listener(resulting_segments);\n        }\n    }\n    cancelCuttingMode() {\n        this.cutting = {\n            enabled: false,\n            id: null,\n            indexes: null\n        };\n        Object.keys(this.cutting_objects).forEach((marker_id) => {\n            //Remove all cutting related markers.\n            this.cutting_objects[marker_id].gmaps_obj.setMap(null);\n            delete this.cutting_objects[marker_id];\n        });\n        if (!this.cutting.id) {\n            console.error(\"No cutting.id set when cancelling cutting mode.\");\n            return;\n        }\n        let polyline = this.map_objects.polyline[this.cutting.id];\n        if (polyline) {\n            let opts = {\n                clickable: true,\n                editable: true\n            };\n            polyline.gmaps_obj.setOptions(opts);\n        }\n    }\n\n\n    render() {\n        return (\n            <div style={{ height: \"100%\" }}>\n                <div ref=\"map\" style={{ position:\"absolute\", top: '0', left: '0', right: '0', bottom: '0' }} />\n            </div>\n        );\n    }\n}\n\n\n\n"]}