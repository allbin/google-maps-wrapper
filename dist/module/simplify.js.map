{"version":3,"sources":["../src/module/simplify.ts"],"names":[],"mappings":"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","file":"simplify.js","sourcesContent":["///////////////\n//MODIFIED BY Joakim Johansson 2018\n\n\n/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// square distance between 2 points\nfunction getSqDist(p1: [number, number], p2: [number, number]) {\n    let dx = p1[0] - p2[0];\n    let dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p: [number, number], p1: [number, number], p2: [number, number]) {\n    let x = p1[0];\n    let y = p1[1];\n    let dx = p2[0] - x;\n    let dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n        let t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points: [number, number][], sqTolerance: number) {\n    let prevPoint = points[0];\n    let newPoints = [prevPoint];\n    let point;\n\n    for (let i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) {\n        newPoints.push(point as [number, number]);\n    }\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points: [number, number][], first: number, last: number, sqTolerance: number, simplified: [number, number][]) {\n    let maxSqDist = sqTolerance;\n    let index: number;\n\n    for (let i = first + 1; i < last; i++) {\n        let sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index! - first > 1) {\n            simplifyDPStep(points, first, index, sqTolerance, simplified);\n        }\n        simplified.push(points[index]);\n        if (last - index > 1) {\n            simplifyDPStep(points, index, last, sqTolerance, simplified);\n        }\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points: [number, number][], sqTolerance: number) {\n    let last = points.length - 1;\n\n    let simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nexport default function simplify(points: [number, number][], tolerance: number, highestQuality: boolean) {\n    if (points.length <= 2) {\n        return points;\n    }\n\n    let sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n"]}