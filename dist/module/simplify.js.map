{"version":3,"sources":["module/simplify.ts"],"names":[],"mappings":"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","file":"simplify.js","sourcesContent":["///////////////\n//MODIFIED BY Joakim Johansson 2018\n\n/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n/** square distance between 2 points. */\nconst getSqDist = (p1: [number, number], p2: [number, number]): number => {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n\n  return dx * dx + dy * dy;\n};\n\n/** square distance from a point to a segment. */\nconst getSqSegDist = (\n  p: [number, number],\n  p1: [number, number],\n  p2: [number, number]\n): number => {\n  let x = p1[0];\n  let y = p1[1];\n  let dx = p2[0] - x;\n  let dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n};\n\n// rest of the code doesn't care about point format\n\n/** basic distance-based simplification. */\nconst simplifyRadialDist = (\n  points: [number, number][],\n  sqTolerance: number\n): [number, number][] => {\n  let prevPoint = points[0];\n  const newPoints = [prevPoint];\n  let point;\n\n  for (let i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n\n  if (prevPoint !== point) {\n    newPoints.push(point as [number, number]);\n  }\n\n  return newPoints;\n};\n\nconst simplifyDPStep = (\n  points: [number, number][],\n  first: number,\n  last: number,\n  sqTolerance: number,\n  simplified: [number, number][]\n): void => {\n  let maxSqDist = sqTolerance;\n  let index = 0;\n\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n};\n\n/** simplification using Ramer-Douglas-Peucker algorithm. */\nconst simplifyDouglasPeucker = (\n  points: [number, number][],\n  sqTolerance: number\n): [number, number][] => {\n  const last = points.length - 1;\n\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n\n  return simplified;\n};\n\n/** both algorithms combined for awesome performance. */\nconst simplify = (\n  points: [number, number][],\n  tolerance: number,\n  highestQuality: boolean\n): [number, number][] => {\n  if (points.length <= 2) {\n    return points;\n  }\n\n  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n\n  return points;\n};\n\nexport default simplify;\n"]}