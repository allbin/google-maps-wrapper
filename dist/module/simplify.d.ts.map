{"version":3,"sources":["../src/module/simplify.ts"],"names":[],"mappings":"AAqHA,wDAAwD;AACxD,QAAA,MAAM,QAAQ,gGAeb,CAAC;AAEF,eAAe,QAAQ,CAAC","file":"simplify.d.ts","sourcesContent":["///////////////\n//MODIFIED BY Joakim Johansson 2018\n\n/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n/** square distance between 2 points. */\nconst getSqDist = (p1: [number, number], p2: [number, number]): number => {\n  const dx = p1[0] - p2[0];\n  const dy = p1[1] - p2[1];\n\n  return dx * dx + dy * dy;\n};\n\n/** square distance from a point to a segment. */\nconst getSqSegDist = (\n  p: [number, number],\n  p1: [number, number],\n  p2: [number, number]\n): number => {\n  let x = p1[0];\n  let y = p1[1];\n  let dx = p2[0] - x;\n  let dy = p2[1] - y;\n\n  if (dx !== 0 || dy !== 0) {\n    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2[0];\n      y = p2[1];\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p[0] - x;\n  dy = p[1] - y;\n\n  return dx * dx + dy * dy;\n};\n\n// rest of the code doesn't care about point format\n\n/** basic distance-based simplification. */\nconst simplifyRadialDist = (\n  points: [number, number][],\n  sqTolerance: number\n): [number, number][] => {\n  let prevPoint = points[0];\n  const newPoints = [prevPoint];\n  let point;\n\n  for (let i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n\n  if (prevPoint !== point) {\n    newPoints.push(point as [number, number]);\n  }\n\n  return newPoints;\n};\n\nconst simplifyDPStep = (\n  points: [number, number][],\n  first: number,\n  last: number,\n  sqTolerance: number,\n  simplified: [number, number][]\n): void => {\n  let maxSqDist = sqTolerance;\n  let index = 0;\n\n  for (let i = first + 1; i < last; i++) {\n    const sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1) {\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    }\n    simplified.push(points[index]);\n    if (last - index > 1) {\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  }\n};\n\n/** simplification using Ramer-Douglas-Peucker algorithm. */\nconst simplifyDouglasPeucker = (\n  points: [number, number][],\n  sqTolerance: number\n): [number, number][] => {\n  const last = points.length - 1;\n\n  const simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n\n  return simplified;\n};\n\n/** both algorithms combined for awesome performance. */\nconst simplify = (\n  points: [number, number][],\n  tolerance: number,\n  highestQuality: boolean\n): [number, number][] => {\n  if (points.length <= 2) {\n    return points;\n  }\n\n  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n\n  return points;\n};\n\nexport default simplify;\n"]}