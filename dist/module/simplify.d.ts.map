{"version":3,"sources":["../src/module/simplify.ts"],"names":[],"mappings":"AAwGA,MAAM,CAAC,OAAO,UAAU,QAAQ,CAAC,MAAM,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,EAAE,SAAS,EAAE,MAAM,EAAE,cAAc,EAAE,OAAO,sBAWtG","file":"simplify.d.ts","sourcesContent":["///////////////\n//MODIFIED BY Joakim Johansson 2018\n\n\n/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// square distance between 2 points\nfunction getSqDist(p1: [number, number], p2: [number, number]) {\n    let dx = p1[0] - p2[0];\n    let dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p: [number, number], p1: [number, number], p2: [number, number]) {\n    let x = p1[0];\n    let y = p1[1];\n    let dx = p2[0] - x;\n    let dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n        let t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points: [number, number][], sqTolerance: number) {\n    let prevPoint = points[0];\n    let newPoints = [prevPoint];\n    let point;\n\n    for (let i = 1, len = points.length; i < len; i++) {\n        point = points[i];\n\n        if (getSqDist(point, prevPoint) > sqTolerance) {\n            newPoints.push(point);\n            prevPoint = point;\n        }\n    }\n\n    if (prevPoint !== point) {\n        newPoints.push(point as [number, number]);\n    }\n\n    return newPoints;\n}\n\nfunction simplifyDPStep(points: [number, number][], first: number, last: number, sqTolerance: number, simplified: [number, number][]) {\n    let maxSqDist = sqTolerance;\n    let index: number;\n\n    for (let i = first + 1; i < last; i++) {\n        let sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n        if (sqDist > maxSqDist) {\n            index = i;\n            maxSqDist = sqDist;\n        }\n    }\n\n    if (maxSqDist > sqTolerance) {\n        if (index! - first > 1) {\n            simplifyDPStep(points, first, index, sqTolerance, simplified);\n        }\n        simplified.push(points[index]);\n        if (last - index > 1) {\n            simplifyDPStep(points, index, last, sqTolerance, simplified);\n        }\n    }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points: [number, number][], sqTolerance: number) {\n    let last = points.length - 1;\n\n    let simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n\n    return simplified;\n}\n\n// both algorithms combined for awesome performance\nexport default function simplify(points: [number, number][], tolerance: number, highestQuality: boolean) {\n    if (points.length <= 2) {\n        return points;\n    }\n\n    let sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n\n    return points;\n}\n"]}