{"version":3,"sources":["../src/module/map_functions.ts"],"names":[],"mappings":";AASA,OAAO,EACL,iBAAiB,EAEjB,oBAAoB,EAMpB,iBAAiB,EACjB,aAAa,EACb,YAAY,EACb,MAAM,GAAG,CAAC;AAEX,eAAO,MAAM,gBAAgB;;;;;aAkB5B,CAAC;AAEF,oDAAoD;AACpD,eAAO,MAAM,SAAS,sGAWrB,CAAC;AAEF,eAAO,MAAM,OAAO,8IAiBnB,CAAC;AAEF,eAAO,MAAM,OAAO,yEAQhB,CAAC;AAEL,eAAO,MAAM,cAAc,wEAW1B,CAAC;AAEF,eAAO,MAAM,aAAa,wEAQvB,CAAC;AAEJ,eAAO,MAAM,SAAS,0JAO8C,CAAC;AACrE,eAAO,MAAM,YAAY,wEAQtB,CAAC;AACJ,eAAO,MAAM,uBAAuB,yGAYnC,CAAC;AAEF,eAAO,MAAM,cAAc,oUAgE1B,CAAC;AACF,eAAO,MAAM,mBAAmB,6FAU/B,CAAC;AACF,eAAO,MAAM,iBAAiB,sJAa7B,CAAC;AAEF,eAAO,MAAM,cAAc,yYA6E1B,CAAC;AACF,eAAO,MAAM,qBAAqB,gIA8CjC,CAAC;AACF,eAAO,MAAM,YAAY,sJA0ExB,CAAC;AACF,eAAO,MAAM,mBAAmB,wKAuD/B,CAAC;AACF,eAAO,MAAM,iBAAiB,2FA4B7B,CAAC","file":"map_functions.d.ts","sourcesContent":["import * as internal_helpers from \"./internal_helpers\";\nimport { haversineDistance, MVCArrayToCoordArray } from \"./external_helpers\";\nimport {\n  CUTTING_SNAP_DISTANCE,\n  Z_INDEX_SCISSORS,\n  Z_INDEX_SCISSORS_HOVER,\n} from \"./constants\";\nimport ScissorIcon from \"./img/marker_scissors.svg\";\nimport ScissorHoverIcon from \"./img/marker_scissors_hover.svg\";\nimport {\n  GMW_LatLngLiteral,\n  GMW_LatLng,\n  GMW_MarkerOptionsSet,\n  GMW_PolylineOptions,\n  GMW_PolygonOptions,\n  GMW_Polygon,\n  GMW_Polyline,\n  GMW_Marker,\n  GMW_WrappedMarker,\n  GMW_DrawingCB,\n  GMW_Services,\n} from \".\";\n\nexport const getBoundsLiteral = (\n  map: google.maps.Map | undefined\n): undefined | { north: number; east: number; south: number; west: number } => {\n  if (!map) {\n    return undefined;\n  }\n  const bounds = map.getBounds();\n  if (!bounds) {\n    return undefined;\n  }\n  const ne = bounds.getNorthEast();\n  const sw = bounds.getSouthWest();\n  return {\n    north: ne.lat(),\n    east: ne.lng(),\n    south: sw.lat(),\n    west: sw.lng(),\n  };\n};\n\n/*** Takes a coordinate and center it on the map  */\nexport const setCenter = (\n  map: google.maps.Map | undefined,\n  lat_lng: GMW_LatLngLiteral | GMW_LatLng\n): Promise<void> => {\n  return new Promise((resolve) => {\n    if (map) {\n      map.setCenter(lat_lng);\n    }\n    resolve();\n    return;\n  });\n};\n\nexport const toPixel = (\n  lat_lng_input: GMW_LatLng | GMW_LatLngLiteral,\n  html_element: any,\n  overlay: google.maps.OverlayView | undefined\n): [number, number] => {\n  if (!overlay) {\n    throw new Error(\"Overlay not loaded when calling toPixel.\");\n  }\n  const node_rect = html_element.getBoundingClientRect();\n  let lat_lng: GMW_LatLng;\n  if (lat_lng_input instanceof google.maps.LatLng) {\n    lat_lng = lat_lng_input;\n  } else {\n    lat_lng = new window.google.maps.LatLng(lat_lng_input);\n  }\n  const pixel_obj = overlay.getProjection().fromLatLngToContainerPixel(lat_lng);\n  return [pixel_obj.x + node_rect.left, pixel_obj.y + node_rect.top];\n};\n\nexport const setZoom = (\n  zoom_level: number,\n  map: google.maps.Map | undefined\n): Promise<void> =>\n  new Promise((resolve) => {\n    map && map.setZoom(zoom_level);\n    resolve();\n    return;\n  });\n\nexport const clearPolylines = (\n  map_objects: MapObjects,\n  cutting: CuttingState\n): Promise<boolean[]> => {\n  const promise_arr: Promise<boolean>[] = [];\n  Object.keys(map_objects.polyline).forEach((id) => {\n    promise_arr.push(\n      internal_helpers.unsetMapObject(map_objects, cutting, \"polyline\", id)\n    );\n  });\n  return Promise.all(promise_arr);\n};\n\nexport const clearPolygons = (\n  map_objects: MapObjects,\n  cutting: CuttingState\n): Promise<boolean[]> =>\n  Promise.all(\n    Object.keys(map_objects.polygon).map((id) =>\n      internal_helpers.unsetMapObject(map_objects, cutting, \"polygon\", id)\n    )\n  );\n\nexport const setMarker = (\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  id: string | number,\n  options: GMW_MarkerOptionsSet\n): Promise<GMW_WrappedMarker> =>\n  internal_helpers.setMarker(map, map_objects, cutting, id, options);\nexport const clearMarkers = (\n  map_objects: MapObjects,\n  cutting: CuttingState\n): Promise<boolean[]> =>\n  Promise.all(\n    Object.keys(map_objects.marker).map((id) =>\n      internal_helpers.unsetMapObject(map_objects, cutting, \"marker\", id)\n    )\n  );\nexport const clearFeatureCollections = (\n  map_objects: MapObjects,\n  features_layer: google.maps.Data,\n  feature_layers: google.maps.Data[]\n): void => {\n  feature_layers.forEach((x) => x.setMap(null));\n  // feature_layers = [];\n  if (features_layer) {\n    Object.keys(map_objects.features).forEach((feature_key) => {\n      map_objects.features[feature_key].remove();\n    });\n  }\n};\n\nexport const setDrawingMode = (\n  services: GMW_Services,\n  type: \"polyline\" | \"polygon\",\n  opts: GMW_PolylineOptions | GMW_PolygonOptions,\n  cb: GMW_DrawingCB,\n  cancel_drawing: boolean,\n  setDrawingCompletedListener: (\n    listener: google.maps.MapsEventListener\n  ) => void,\n  drawing_completed_listener?: google.maps.MapsEventListener\n): void => {\n  let mode = null;\n  if (!services.drawing) {\n    console.error(\n      \"MAP: Drawing library not available! Add it to google maps api request url.\"\n    );\n    return;\n  }\n  if (\n    Object.prototype.hasOwnProperty.call(\n      services.drawing.OverlayType,\n      type.toUpperCase()\n    )\n  ) {\n    mode = services.drawing.OverlayType[type.toUpperCase()];\n  } else {\n    throw new Error(\"MAP: Invalid drawing mode type:\" + type);\n  }\n  const drawing_opts = Object.assign({}, opts, { drawingMode: mode });\n  services.drawingManager.setOptions(drawing_opts);\n  console.log(\"MAP: Drawing mode started for:\", type + \".\");\n  cancel_drawing = false;\n\n  if (drawing_completed_listener) {\n    drawing_completed_listener.remove();\n  }\n  setDrawingCompletedListener(\n    google.maps.event.addListenerOnce(\n      services.drawingManager,\n      \"overlaycomplete\",\n      (e: google.maps.drawing.OverlayCompleteEvent) => {\n        // console.log(\"overlay complete\", cb, cancel_drawing);\n        e.overlay.setMap(null);\n        drawing_opts.drawingMode = null;\n        services.drawingManager.setOptions(drawing_opts);\n        if (!cb || cancel_drawing) {\n          return;\n        }\n        if (type === \"polyline\" || type === \"polygon\") {\n          const overlay = e.overlay as GMW_Polygon | GMW_Polyline;\n          const path = MVCArrayToCoordArray(overlay.getPath());\n          if (cb) {\n            cb(path as [number, number][], overlay);\n          }\n        } else if (type === \"marker\") {\n          const overlay = e.overlay as GMW_Marker;\n          const pos = overlay.getPosition();\n          cb([pos.lat(), pos.lng()], overlay);\n        } else {\n          cb(null, e.overlay as any);\n        }\n      }\n    )\n  );\n};\nexport const completeDrawingMode = (\n  services: GMW_Services,\n  drawing_completed_listener: google.maps.MapsEventListener\n): void => {\n  if (services.drawing) {\n    services.drawingManager.setOptions({ drawingMode: null });\n  }\n  if (drawing_completed_listener) {\n    drawing_completed_listener.remove();\n  }\n};\nexport const cancelDrawingMode = (\n  services: GMW_Services,\n  cancel_drawing: boolean,\n  drawing_completed_listener: google.maps.MapsEventListener,\n  debug_src?: string\n): void => {\n  if (debug_src) {\n    console.log(\"cancel drawing mode:\", debug_src);\n  }\n  if (services.drawing && drawing_completed_listener) {\n    cancel_drawing = true;\n    services.drawingManager.setOptions({ drawingMode: null });\n  }\n};\n\nexport const setCuttingMode = (\n  services: GMW_Services,\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  cutting_objects: CuttingObjects,\n  default_center: GMW_LatLngLiteral,\n  cancel_drawing: boolean,\n  drawing_completed_listener: google.maps.MapsEventListener,\n  polyline_id: string | number,\n  cutting_completed_listener: (segments: [number, number][][] | null) => void,\n  cb?: () => any\n): void => {\n  if (\n    !Object.prototype.hasOwnProperty.call(map_objects.polyline, polyline_id)\n  ) {\n    console.error(\n      \"MAP: Cannot set cutting mode, provided object id not on map: \",\n      polyline_id\n    );\n    return;\n  }\n  if (!cb) {\n    console.error(\n      \"MAP: Cannot setCuttingMode without supplying completed callback.\"\n    );\n    return;\n  }\n  cancelDrawingMode(\n    services,\n    cancel_drawing,\n    drawing_completed_listener,\n    \"setCuttingMode\"\n  );\n  const polyline = map_objects.polyline[polyline_id];\n  const opts = {\n    clickable: false,\n    editable: false,\n  };\n  polyline.gmaps_obj.setOptions(opts);\n\n  const path = polyline.options.path;\n  cutting = {\n    enabled: true,\n    id: polyline_id,\n    indexes: [],\n    arr: path as any,\n  };\n  if (\n    !Object.prototype.hasOwnProperty.call(cutting_objects, \"hover_scissors\")\n  ) {\n    const opts = {\n      position: default_center,\n      icon: {\n        url: ScissorHoverIcon,\n      },\n      zIndex: Z_INDEX_SCISSORS_HOVER,\n      visible: false,\n      clickable: false,\n      editable: false,\n      draggable: false,\n    };\n    const hover_scissors = {\n      gmaps_obj: new window.google.maps.Marker(opts),\n      options: opts,\n    };\n    hover_scissors.gmaps_obj.setMap(map);\n    cutting_objects.hover_scissors = hover_scissors;\n  }\n  console.log(\"MAP: Cutting mode started for id: \" + polyline_id);\n  cutting_completed_listener = (value) => {\n    if (cb) {\n      (cb as any)(value);\n    } else {\n      throw new Error(\"Callback for cutting completed not defined.\");\n    }\n  };\n};\nexport const cuttingPositionUpdate = (\n  mouse_event: google.maps.MouseEvent,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  cutting_objects: CuttingObjects\n): void => {\n  if (!cutting.enabled || !cutting.id) {\n    //If we are not in cutting mode ignore function call.\n    return;\n  }\n  const polyline = map_objects.polyline[cutting.id];\n  const mouse_coord = {\n    lat: mouse_event.latLng.lat(),\n    lng: mouse_event.latLng.lng(),\n  };\n  let closest_index = 0;\n  let closest_dist = Infinity;\n  //Find nearest index and move scissors_hover marker.\n  polyline.gmaps_obj.getPath().forEach((point, i: number) => {\n    const dist = haversineDistance(mouse_coord, {\n      lat: point.lat(),\n      lng: point.lng(),\n    });\n    if (dist < closest_dist) {\n      closest_index = i;\n      closest_dist = dist;\n    }\n  });\n  const path = polyline.gmaps_obj.getPath().getArray();\n  if (\n    closest_dist < CUTTING_SNAP_DISTANCE &&\n    closest_index > 0 &&\n    closest_index < path.length - 1\n  ) {\n    cutting_objects.hover_scissors.gmaps_obj.setOptions({\n      position: {\n        lat: path[closest_index].lat(),\n        lng: path[closest_index].lng(),\n      },\n      visible: true,\n    });\n  } else {\n    cutting_objects.hover_scissors.gmaps_obj.setOptions({\n      visible: false,\n    });\n  }\n};\nexport const cuttingClick = (\n  mouse_event: google.maps.MouseEvent,\n  map: google.maps.Map,\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  cutting_objects: CuttingObjects\n): void => {\n  if (!cutting.id) {\n    console.error(\"No cutting.id set when clicking for cut.\");\n    return;\n  }\n  if (!cutting.indexes) {\n    console.error(\"cutting.indexes not defined when clicking for cut.\");\n    return;\n  }\n  const polyline = map_objects.polyline[cutting.id];\n  const path = polyline.options.path as any;\n  const mouse_coord = {\n    lat: mouse_event.latLng.lat(),\n    lng: mouse_event.latLng.lng(),\n  };\n  let closest_index = 0;\n  let closest_dist = Infinity;\n  path.forEach((point: any, i: number) => {\n    const dist = haversineDistance(mouse_coord, point);\n    if (dist < closest_dist) {\n      closest_index = i;\n      closest_dist = dist;\n    }\n  });\n  if (closest_dist > CUTTING_SNAP_DISTANCE) {\n    //Pointer is too far away from any point, ignore.\n    return;\n  }\n  if (closest_index === 0 || closest_index === path.length - 1) {\n    //We are never interested in first or last point.\n    return;\n  }\n  const already_selected_position = cutting.indexes.findIndex(\n    (value) => closest_index === value\n  );\n  if (already_selected_position > -1) {\n    //This index has already been selected for cutting, remove it.\n    cutting.indexes.splice(already_selected_position, 1);\n    if (\n      Object.prototype.hasOwnProperty.call(\n        cutting_objects,\n        \"index_\" + closest_index\n      )\n    ) {\n      //We have drawn a marker for cut, remove it.\n      cutting_objects[\"index_\" + closest_index].gmaps_obj.setMap(null);\n      delete cutting_objects[\"index_\" + closest_index];\n    }\n  } else {\n    cutting.indexes.push(closest_index);\n    const opts = {\n      position: path[closest_index],\n      icon: {\n        url: ScissorIcon,\n      },\n      zIndex: Z_INDEX_SCISSORS,\n      visible: true,\n      clickable: false,\n      editable: false,\n      draggable: false,\n    };\n    const cut_marker = {\n      gmaps_obj: new window.google.maps.Marker(opts),\n      options: opts,\n    };\n    cut_marker.gmaps_obj.setMap(map);\n    cutting_objects[\"index_\" + closest_index] = cut_marker;\n  }\n};\nexport const completeCuttingMode = (\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  cutting_objects: CuttingObjects,\n  cutting_completed_listener: (segments: [number, number][][] | null) => void\n): void => {\n  if (!cutting || cutting.id === null) {\n    return;\n  }\n  const indexes = cutting.indexes;\n  const polyline = map_objects.polyline[cutting.id];\n  if (!polyline) {\n    return;\n  }\n  // TODO do not reassign inside function\n  cutting = {\n    enabled: false,\n    id: null,\n    indexes: null,\n  };\n  Object.keys(cutting_objects).forEach((marker_id) => {\n    //Remove all cutting related markers.\n    cutting_objects[marker_id].gmaps_obj.setMap(null);\n    delete cutting_objects[marker_id];\n  });\n\n  const opts = {\n    clickable: true,\n    editable: true,\n  };\n  polyline.gmaps_obj.setOptions(opts);\n  if (!indexes || indexes.length === 0) {\n    //We made no selections, just return.\n    if (cutting_completed_listener) {\n      cutting_completed_listener(null);\n    }\n    return;\n  }\n\n  const path = (polyline.options.path as unknown) as [number, number][];\n  indexes.sort();\n  //Add last index so that the remaining points form a segment as well.\n  indexes.push(path.length - 1);\n  const resulting_segments: [number, number][][] = [];\n  let prev_index = 0;\n  indexes.forEach((index) => {\n    const segment = path.slice(prev_index, index);\n    //Copy last point as well.\n    segment.push(path[index]);\n    resulting_segments.push(segment);\n    prev_index = index;\n  });\n  if (cutting_completed_listener) {\n    cutting_completed_listener(resulting_segments);\n  }\n};\nexport const cancelCuttingMode = (\n  map_objects: MapObjects,\n  cutting: CuttingState,\n  cutting_objects: CuttingObjects\n): void => {\n  //TODO no reassign of prameter\n  cutting = {\n    enabled: false,\n    id: null,\n    indexes: null,\n  };\n  Object.keys(cutting_objects).forEach((marker_id) => {\n    //Remove all cutting related markers.\n    cutting_objects[marker_id].gmaps_obj.setMap(null);\n    delete cutting_objects[marker_id];\n  });\n  if (!cutting.id) {\n    console.error(\"No cutting.id set when cancelling cutting mode.\");\n    return;\n  }\n  const polyline = map_objects.polyline[cutting.id];\n  if (polyline) {\n    const opts = {\n      clickable: true,\n      editable: true,\n    };\n    polyline.gmaps_obj.setOptions(opts);\n  }\n};\n"]}