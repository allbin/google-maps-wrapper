{"version":3,"sources":["../src/module/WrappedMapBase.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAsC,MAAM,OAAO,CAAC;AAC3D,OAAO,eAAe,EAAE,EACtB,sBAAsB,EAEvB,MAAM,6BAA6B,CAAC;AAWrC,OAAO,EACL,uBAAuB,EACvB,iBAAiB,EACjB,UAAU,EACV,sBAAsB,EACtB,qBAAqB,EACrB,oBAAoB,EACpB,mBAAmB,EACnB,kBAAkB,EAClB,mBAAmB,EACnB,kBAAkB,EAClB,iBAAiB,EACjB,qBAAqB,EACrB,kBAAkB,EAClB,aAAa,EACb,YAAY,EACb,MAAM,GAAG,CAAC;AAEX,oBAAY,iBAAiB,GAAG;IAC9B,gBAAgB,EAAE,MAAM,uBAAuB,GAAG,SAAS,CAAC;IAC5D,SAAS,EAAE,CAAC,OAAO,EAAE,iBAAiB,GAAG,UAAU,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;IACtE,OAAO,EAAE,CAAC,aAAa,EAAE,UAAU,GAAG,iBAAiB,KAAK,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IAC7E,OAAO,EAAE,CAAC,UAAU,EAAE,MAAM,KAAK,OAAO,CAAC,IAAI,CAAC,CAAC;IAC/C,WAAW,EAAE,CACX,EAAE,EAAE,MAAM,GAAG,MAAM,EACnB,OAAO,EAAE,sBAAsB,KAC5B,OAAO,CAAC,mBAAmB,CAAC,CAAC;IAClC,UAAU,EAAE,CACV,EAAE,EAAE,MAAM,GAAG,MAAM,EACnB,OAAO,EAAE,qBAAqB,KAC3B,OAAO,CAAC,kBAAkB,CAAC,CAAC;IACjC,aAAa,EAAE,CAAC,EAAE,EAAE,MAAM,GAAG,MAAM,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;IACzD,YAAY,EAAE,CAAC,EAAE,EAAE,MAAM,GAAG,MAAM,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;IACxD,WAAW,EAAE,CAAC,EAAE,EAAE,MAAM,GAAG,MAAM,KAAK,OAAO,CAAC,OAAO,CAAC,CAAC;IACvD,cAAc,EAAE,MAAM,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;IACzC,aAAa,EAAE,MAAM,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;IACxC,uBAAuB,EAAE,CACvB,WAAW,EAAE,UAAU,EACvB,aAAa,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,EAC/B,cAAc,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,EAAE,KAC/B,IAAI,CAAC;IACV,SAAS,EAAE,CACT,EAAE,EAAE,MAAM,GAAG,MAAM,EACnB,OAAO,EAAE,oBAAoB,KAC1B,OAAO,CAAC,iBAAiB,CAAC,CAAC;IAChC,YAAY,EAAE,MAAM,OAAO,CAAC,OAAO,EAAE,CAAC,CAAC;IACvC,oBAAoB,EAAE,CACpB,UAAU,EAAE,wBAAwB,EACpC,OAAO,EAAE,qBAAqB,KAC3B,OAAO,CAAC;QACX,KAAK,EAAE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;QACxB,QAAQ,EAAE,kBAAkB,EAAE,CAAC;KAChC,CAAC,CAAC;IACH,iBAAiB,EAAE,CACjB,OAAO,EAAE,cAAc,EACvB,OAAO,EAAE,qBAAqB,KAC3B,OAAO,CAAC,kBAAkB,CAAC,CAAC;IACjC,YAAY,EAAE,CACZ,IAAI,EACA,iBAAiB,GACjB,kBAAkB,GAClB,mBAAmB,GACnB,kBAAkB,KACnB,IAAI,CAAC;IACV,WAAW,EAAE,CACX,IAAI,EACA,iBAAiB,GACjB,kBAAkB,GAClB,mBAAmB,GACnB,kBAAkB,KACnB,IAAI,CAAC;IACV,cAAc,EAAE,CACd,IAAI,EAAE,UAAU,GAAG,SAAS,EAC5B,IAAI,EAAE,mBAAmB,GAAG,kBAAkB,EAC9C,EAAE,EAAE,aAAa,KACd,IAAI,CAAC;IACV,iBAAiB,EAAE,CAAC,cAAc,EAAE,OAAO,EAAE,SAAS,CAAC,EAAE,MAAM,KAAK,IAAI,CAAC;IACzE,cAAc,EAAE,CAAC,WAAW,EAAE,MAAM,GAAG,MAAM,EAAE,EAAE,CAAC,EAAE,MAAM,GAAG,KAAK,IAAI,CAAC;IACvE,qBAAqB,EAAE,CAAC,WAAW,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,KAAK,IAAI,CAAC;IACrE,YAAY,EAAE,CAAC,WAAW,EAAE,MAAM,CAAC,IAAI,CAAC,UAAU,KAAK,IAAI,CAAC;IAC5D,mBAAmB,EAAE,MAAM,IAAI,CAAC;IAChC,iBAAiB,EAAE,MAAM,IAAI,CAAC;IAC9B,mBAAmB,EAAE,CAAC,EAAE,EAAE,MAAM,IAAI,KAAK,MAAM,CAAC;IAChD,qBAAqB,EAAE,CAAC,EAAE,EAAE,MAAM,IAAI,KAAK,IAAI,CAAC;IAChD,iBAAiB,EAAE,CAAC,EAAE,EAAE,MAAM,IAAI,KAAK,MAAM,CAAC;IAC9C,mBAAmB,EAAE,CAAC,EAAE,EAAE,MAAM,IAAI,KAAK,IAAI,CAAC;IAC9C,aAAa,EAAE,MAAM,OAAO,CAAC,eAAe,EAAE,CAAC,CAAC;IAChD,YAAY,EAAE,CACZ,iBAAiB,EAAE,sBAAsB,KACtC,OAAO,CAAC,eAAe,CAAC,CAAC;IAC9B,cAAc,EAAE,CAAC,SAAS,EAAE,eAAe,KAAK,IAAI,CAAC;IACrD,oBAAoB,EAAE,OAAO,eAAe,CAAC,gBAAgB,CAAC;IAC9D,mDAAmD;IACnD,WAAW,EAAE,MAAM,YAAY,CAAC;CACjC,CAAC;AAEF,MAAM,WAAW,YAAY;IAC3B,aAAa,CAAC,EAAE,CAAC,GAAG,EAAE,MAAM,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,iBAAiB,KAAK,IAAI,CAAC;IACzE,kBAAkB,EAAE,MAAM,CAAC;IAC3B,EAAE,CAAC,EAAE,MAAM,CAAC;IACZ,cAAc,EAAE,iBAAiB,CAAC;IAClC,YAAY,EAAE,MAAM,CAAC;IACrB,eAAe,CAAC,EAAE,MAAM,CAAC;IACzB,eAAe,CAAC,EAAE,MAAM,IAAI,CAAC;IAC7B,eAAe,CAAC,EAAE,MAAM,IAAI,CAAC;IAC7B,OAAO,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,CAAC;IAC3B,aAAa,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,CAAC;IACjC,MAAM,CAAC,EAAE,MAAM,IAAI,CAAC;IACpB,SAAS,CAAC,EAAE,MAAM,IAAI,CAAC;IACvB,WAAW,CAAC,EAAE,MAAM,IAAI,CAAC;IACzB,gBAAgB,CAAC,EAAE,MAAM,IAAI,CAAC;IAC9B,MAAM,CAAC,EAAE,MAAM,IAAI,CAAC;IACpB,kBAAkB,CAAC,EAAE,MAAM,IAAI,CAAC;IAChC,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,CAAC;IAC/B,UAAU,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,CAAC;IAC9B,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,CAAC;IAC/B,mBAAmB,CAAC,EAAE,MAAM,IAAI,CAAC;IACjC,QAAQ,CAAC,EAAE,MAAM,IAAI,CAAC;IACtB,YAAY,CAAC,EAAE,CAAC,CAAC,EAAE,GAAG,KAAK,IAAI,CAAC;IAChC,aAAa,CAAC,EAAE,MAAM,IAAI,CAAC;IAC3B,aAAa,CAAC,EAAE,MAAM,IAAI,CAAC;IAC3B,aAAa,CAAC,EAAE,MAAM,IAAI,CAAC;IAC3B,MAAM,CAAC,EAAE,MAAM,CAAC;CACjB;AACD,eAAO,MAAM,cAAc,EAAE,KAAK,CAAC,iBAAiB,CAAC,YAAY,CA2dhE,CAAC;AACF,eAAe,cAAc,CAAC","file":"WrappedMapBase.d.ts","sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport MarkerClusterer, {\n  MarkerClustererOptions,\n  ClusterIconStyle,\n} from \"@google/markerclustererplus\";\nimport ScriptCache from \"./ScriptCache\";\nimport * as feature_helpers from \"./feature_helpers\";\nimport * as map_funcs from \"./map_functions\";\nimport {\n  panZoomToObjectOrFeature,\n  setMarker,\n  setPolygon,\n  setPolyline,\n  unsetMapObject,\n} from \"./internal_helpers\";\nimport {\n  GMW_LatLngBoundsLiteral,\n  GMW_LatLngLiteral,\n  GMW_LatLng,\n  GMW_PolylineOptionsSet,\n  GMW_PolygonOptionsSet,\n  GMW_MarkerOptionsSet,\n  GMW_PolylineOptions,\n  GMW_PolygonOptions,\n  GMW_WrappedPolyline,\n  GMW_WrappedPolygon,\n  GMW_WrappedMarker,\n  GMW_FeatureOptionsSet,\n  GMW_WrappedFeature,\n  GMW_DrawingCB,\n  GMW_Services,\n} from \".\";\n\nexport type ExportedFunctions = {\n  getBoundsLiteral: () => GMW_LatLngBoundsLiteral | undefined;\n  setCenter: (lat_lng: GMW_LatLngLiteral | GMW_LatLng) => Promise<void>;\n  toPixel: (lat_lng_pixel: GMW_LatLng | GMW_LatLngLiteral) => [number, number];\n  setZoom: (zoom_level: number) => Promise<void>;\n  setPolyline: (\n    id: string | number,\n    options: GMW_PolylineOptionsSet\n  ) => Promise<GMW_WrappedPolyline>;\n  setPolygon: (\n    id: string | number,\n    options: GMW_PolygonOptionsSet\n  ) => Promise<GMW_WrappedPolygon>;\n  unsetPolyline: (id: string | number) => Promise<boolean>;\n  unsetPolygon: (id: string | number) => Promise<boolean>;\n  unsetMarker: (id: string | number) => Promise<boolean>;\n  clearPolylines: () => Promise<boolean[]>;\n  clearPolygons: () => Promise<boolean[]>;\n  clearFeatureCollections: (\n    map_objects: MapObjects,\n    feature_layer: google.maps.Data,\n    feature_layers: google.maps.Data[]\n  ) => void;\n  setMarker: (\n    id: string | number,\n    options: GMW_MarkerOptionsSet\n  ) => Promise<GMW_WrappedMarker>;\n  clearMarkers: () => Promise<boolean[]>;\n  setGeoJSONCollection: (\n    collection: GeoJSONFeatureCollection,\n    options: GMW_FeatureOptionsSet\n  ) => Promise<{\n    layer: google.maps.Data;\n    features: GMW_WrappedFeature[];\n  }>;\n  setGeoJSONFeature: (\n    feature: GeoJSONFeature,\n    options: GMW_FeatureOptionsSet\n  ) => Promise<GMW_WrappedFeature>;\n  zoomToObject: (\n    item:\n      | GMW_WrappedMarker\n      | GMW_WrappedPolygon\n      | GMW_WrappedPolyline\n      | GMW_WrappedFeature\n  ) => void;\n  panToObject: (\n    item:\n      | GMW_WrappedMarker\n      | GMW_WrappedPolygon\n      | GMW_WrappedPolyline\n      | GMW_WrappedFeature\n  ) => void;\n  setDrawingMode: (\n    type: \"polyline\" | \"polygon\",\n    opts: GMW_PolylineOptions | GMW_PolygonOptions,\n    cb: GMW_DrawingCB\n  ) => void;\n  cancelDrawingMode: (cancel_drawing: boolean, debug_src?: string) => void;\n  setCuttingMode: (polyline_id: string | number, cb?: () => any) => void;\n  cuttingPositionUpdate: (mouse_event: google.maps.MouseEvent) => void;\n  cuttingClick: (mouse_event: google.maps.MouseEvent) => void;\n  completeCuttingMode: () => void;\n  cancelCuttingMode: () => void;\n  registerDragStartCB: (cb: () => void) => number;\n  unregisterDragStartCB: (cb: () => void) => void;\n  registerDragEndCB: (cb: () => void) => number;\n  unregisterDragEndCB: (cb: () => void) => void;\n  getClusterers: () => Promise<MarkerClusterer[]>;\n  setClusterer: (\n    clusterer_options: MarkerClustererOptions\n  ) => Promise<MarkerClusterer>;\n  unsetClusterer: (clusterer: MarkerClusterer) => void;\n  createClustererStyle: typeof MarkerClusterer.withDefaultStyle;\n  /** Ensure to only use after map initialization. */\n  getServices: () => GMW_Services;\n};\n\nexport interface MapBaseProps {\n  initializedCB?: (map: google.maps.Map, funcs: ExportedFunctions) => void;\n  googleapi_maps_uri: string;\n  id?: string;\n  default_center: GMW_LatLngLiteral;\n  default_zoom: number;\n  default_options?: object;\n  onCenterChanged?: () => void;\n  onBoundsChanged?: () => void;\n  onClick?: (e: any) => void;\n  onDoubleClick?: (e: any) => void;\n  onDrag?: () => void;\n  onDragEnd?: () => void;\n  onDragStart?: () => void;\n  onHeadingChanged?: () => void;\n  onIdle?: () => void;\n  onMapTypeIdChanged?: () => void;\n  onMouseMove?: (e: any) => void;\n  onMouseOut?: (e: any) => void;\n  onMouseOver?: (e: any) => void;\n  onProjectionChanged?: () => void;\n  onResize?: () => void;\n  onRightClick?: (e: any) => void;\n  onTilesLoaded?: () => void;\n  onTiltChanged?: () => void;\n  onZoomChanged?: () => void;\n  styles?: object;\n}\nexport const WrappedMapBase: React.FunctionComponent<MapBaseProps> = ({\n  googleapi_maps_uri,\n  default_center,\n  default_options,\n  default_zoom,\n  onDoubleClick,\n  onBoundsChanged,\n  onCenterChanged,\n  onClick,\n  onDrag,\n  onDragEnd,\n  onDragStart,\n  onHeadingChanged,\n  onIdle,\n  onMapTypeIdChanged,\n  onMouseMove,\n  onMouseOut,\n  onMouseOver,\n  onProjectionChanged,\n  onResize,\n  onRightClick,\n  onTilesLoaded,\n  onTiltChanged,\n  onZoomChanged,\n  styles,\n  initializedCB,\n}) => {\n  const [script_cache] = useState<any>(\n    ScriptCache({\n      google: googleapi_maps_uri,\n    })\n  );\n\n  const [clusterers] = useState<MarkerClusterer[]>([]);\n  const [map, setMap] = useState<google.maps.Map>();\n  const [do_after_init] = useState<((map: google.maps.Map) => void)[]>([]);\n  const [do_on_drag_end] = useState<(() => void)[]>([]);\n  const [do_on_drag_start] = useState<(() => void)[]>([]);\n  const [drawing_completed_listener, setDrawingCompletedListener] = useState<\n    google.maps.MapsEventListener\n  >();\n  const [features_layer, setFeaturesLayer] = useState<google.maps.Data>();\n  const [feature_layers] = useState<google.maps.Data[]>();\n  const [map_objects] = useState<MapObjects>({\n    marker: {},\n    polygon: {},\n    polyline: {},\n    features: {},\n  });\n  const [cutting_objects] = useState<CuttingObjects>({});\n  const [overlay, setOverlay] = useState<google.maps.OverlayView>();\n\n  const [cutting] = useState<CuttingState>({\n    enabled: false,\n    id: null,\n    indexes: null,\n  });\n  const [cutting_completed_listener] = useState<\n    (segments: [number, number][][] | null) => void\n  >();\n  const [cancel_drawing] = useState<boolean>(false);\n  const [services, setServices] = useState<GMW_Services>();\n  const html_element_ref = useRef(null);\n  const ic = <T extends any>(\n    fn: (map: google.maps.Map) => Promise<T>\n  ): Promise<T> =>\n    new Promise((resolve, reject) => {\n      if (!map) {\n        do_after_init.push((map) => {\n          fn(map).then(resolve).catch(reject);\n        });\n      } else {\n        fn(map).then(resolve);\n      }\n    });\n\n  const [funcs, setFuncs] = useState<ExportedFunctions>();\n\n  useEffect(() => {\n    if (!html_element_ref.current) {\n      throw new Error(\"html element not found.\");\n    }\n\n    script_cache.google.onLoad(() => {\n      const center = default_center;\n      if (!center) {\n        throw new Error(\n          \"Could not create map: Requires 'default_center' prop.\"\n        );\n      }\n      const zoom = typeof default_zoom !== \"undefined\" ? default_zoom : null;\n      if (!zoom) {\n        throw new Error(\"Could not create map: Requires 'default_zoom' prop.\");\n      }\n      if (!googleapi_maps_uri) {\n        throw new Error(\n          \"Could not create map: Requires 'googleapi_maps_uri' prop. Ex: https://maps.googleapis.com/maps/api/js?v=3.exp&libraries=geometry,places,drawing&key=XXXXXXXXXX\"\n        );\n      }\n      const defaults = default_options || {};\n      const mapConfig = Object.assign({}, defaults, {\n        center: new window.google.maps.LatLng(center.lat, center.lng),\n        zoom: zoom,\n        gestureHandling: \"greedy\",\n        styles: styles || {},\n      });\n      const maps = window.google.maps;\n      const initial_map = new maps.Map(html_element_ref.current, mapConfig);\n      setMap(initial_map);\n    });\n    return () => {\n      if (map) {\n        window.google.maps.event.clearInstanceListeners(map);\n      }\n    };\n  }, []);\n  useEffect(() => {\n    if (!map) {\n      return;\n    }\n    const initial_services: GMW_Services = {\n      geocoderService: new window.google.maps.Geocoder(),\n      directionsService: new window.google.maps.DirectionsService(),\n    };\n    if (window.google.maps.drawing) {\n      initial_services.drawing = window.google.maps.drawing;\n      initial_services.drawingManager = new window.google.maps.drawing.DrawingManager(\n        {\n          drawingMode: null,\n          drawingControl: false,\n          drawingControlOptions: {\n            drawingModes: [],\n          },\n        }\n      );\n      initial_services.drawingManager.setMap(map);\n    }\n\n    setServices(initial_services);\n  }, [map]);\n  useEffect(() => {\n    if (!map || !services) {\n      return;\n    }\n    setFuncs({\n      getBoundsLiteral: () => map_funcs.getBoundsLiteral(map),\n      setCenter: (lat_lng) =>\n        ic<void>((map) => map_funcs.setCenter(map, lat_lng)),\n      toPixel: (lat_lng_pixel) =>\n        map_funcs.toPixel(lat_lng_pixel, html_element_ref, overlay),\n      setZoom: (zoom_level) => ic((map) => map_funcs.setZoom(zoom_level, map)),\n      setPolyline: (id, options) =>\n        ic((map) => setPolyline(map, map_objects, cutting, id, options)),\n      setPolygon: (id, options) =>\n        ic((map: google.maps.Map) =>\n          setPolygon(map, map_objects, cutting, id, options)\n        ),\n      unsetPolyline: (id) =>\n        unsetMapObject(map_objects, cutting, \"polyline\", id),\n      unsetPolygon: (id) => unsetMapObject(map_objects, cutting, \"polygon\", id),\n      clearPolylines: () => map_funcs.clearPolylines(map_objects, cutting),\n      clearPolygons: () => map_funcs.clearPolygons(map_objects, cutting),\n      setMarker: (id, options) =>\n        ic((map) => setMarker(map, map_objects, cutting, id, options)),\n      unsetMarker: (id) => unsetMapObject(map_objects, cutting, \"marker\", id),\n      clearMarkers: () => map_funcs.clearMarkers(map_objects, cutting),\n      setGeoJSONCollection: (collection, options) =>\n        ic((map) =>\n          feature_helpers.setGeoJSONCollection(\n            map,\n            map_objects,\n            collection,\n            options\n          )\n        ),\n      setGeoJSONFeature: (feature, options) =>\n        ic((map) => {\n          if (!features_layer) {\n            throw new Error(\"features layer not loaded.\");\n          }\n          return feature_helpers.setGeoJSONFeature(\n            map,\n            map_objects,\n            features_layer,\n            feature,\n            options\n          );\n        }),\n      clearFeatureCollections: () => {\n        if (!features_layer || !feature_layers) {\n          throw new Error(\"features/feature layer/layers not loaded.\");\n        }\n        map_funcs.clearFeatureCollections(\n          map_objects,\n          features_layer,\n          feature_layers\n        );\n      },\n      zoomToObject: (item) => map && panZoomToObjectOrFeature(map, item, true),\n      panToObject: (item) => map && panZoomToObjectOrFeature(map, item, false),\n      setDrawingMode: (type, opts, cb) => {\n        map_funcs.setDrawingMode(\n          services,\n          type,\n          opts,\n          cb,\n          cancel_drawing,\n          setDrawingCompletedListener,\n          drawing_completed_listener\n        );\n      },\n      cancelDrawingMode: (cancel_drawing, debug_src) =>\n        drawing_completed_listener &&\n        map_funcs.cancelDrawingMode(\n          services,\n          cancel_drawing,\n          drawing_completed_listener,\n          debug_src\n        ),\n      setCuttingMode: (polyline_id, cb) =>\n        drawing_completed_listener &&\n        cutting_completed_listener &&\n        map_funcs.setCuttingMode(\n          services,\n          map,\n          map_objects,\n          cutting,\n          cutting_objects,\n          default_center,\n          cancel_drawing,\n          drawing_completed_listener,\n          polyline_id,\n          cutting_completed_listener,\n          cb\n        ),\n      cuttingPositionUpdate: (mouse_event) =>\n        map_funcs.cuttingPositionUpdate(\n          mouse_event,\n          map_objects,\n          cutting,\n          cutting_objects\n        ),\n      cuttingClick: (mouse_event) =>\n        map_funcs.cuttingClick(\n          mouse_event,\n          map,\n          map_objects,\n          cutting,\n          cutting_objects\n        ),\n      completeCuttingMode: () =>\n        cutting_completed_listener &&\n        map_funcs.completeCuttingMode(\n          map_objects,\n          cutting,\n          cutting_objects,\n          cutting_completed_listener\n        ),\n      cancelCuttingMode: () =>\n        map_funcs.cancelCuttingMode(map_objects, cutting, cutting_objects),\n      registerDragStartCB: (cb) => do_on_drag_end.push(cb),\n      unregisterDragStartCB: (cb) => {\n        const index = do_on_drag_start.indexOf(cb);\n        if (index > -1) {\n          do_on_drag_start.splice(index, 1);\n        }\n      },\n      registerDragEndCB: (cb) => do_on_drag_end.push(cb),\n      unregisterDragEndCB: (cb) => {\n        const index = do_on_drag_end.indexOf(cb);\n        if (index > -1) {\n          do_on_drag_end.splice(index, 1);\n        }\n      },\n      /** *Never use the MarkerClusterer.clearMarkers() function, use the maps unsetClusterer instead!*\n       *  NOTE: This will make marker.show() and marker.hide() not function properly, since visibility is controlled by the cluster.\n       */\n      setClusterer: (clusterer_options) =>\n        ic((map) => {\n          const clusterer = new MarkerClusterer(map, [], clusterer_options);\n          clusterers.push(clusterer);\n          return Promise.resolve(clusterer);\n        }),\n      /** *Never use the MarkerClusterer.clearMarkers() function, use the maps unsetClusterer instead!*\n       *  NOTE: This will make marker.show() and marker.hide() not function properly, since visibility is controlled by the cluster.\n       */\n      getClusterers: () => ic(() => Promise.resolve([...clusterers])),\n      unsetClusterer: (clusterer) => {\n        clusterer.removeMarkers(clusterer.getMarkers());\n        const index = clusterers.indexOf(clusterer);\n        if (index > -1) {\n          clusterers.splice(index, 1);\n        }\n      },\n      createClustererStyle: (styling: ClusterIconStyle) =>\n        MarkerClusterer.withDefaultStyle(styling),\n      getServices: () => {\n        return services;\n      },\n    });\n\n    //\n    //\n    //\n    const initial_features_layer = new window.google.maps.Data();\n    setFeaturesLayer(initial_features_layer);\n    initial_features_layer.setMap(map);\n    feature_helpers.setupLayerEvents(map_objects, initial_features_layer);\n    //eslint-disable-next-line\n    function CanvasProjectionOverlay() {}\n    CanvasProjectionOverlay.prototype = new window.google.maps.OverlayView();\n    CanvasProjectionOverlay.prototype.constructor = CanvasProjectionOverlay;\n    CanvasProjectionOverlay.prototype.onAdd = () => {\n      /***/\n    };\n    CanvasProjectionOverlay.prototype.draw = () => {\n      /***/\n    };\n    CanvasProjectionOverlay.prototype.onRemove = () => {\n      /***/\n    };\n    const initial_overlay = new (CanvasProjectionOverlay as any)(/***/);\n    setOverlay(initial_overlay);\n    if (initial_overlay) {\n      initial_overlay.setMap(map);\n    }\n  }, [services]);\n\n  useEffect(() => {\n    if (!funcs || !map || !features_layer || !services) {\n      return;\n    }\n    setupMapEvents(map);\n\n    window.google.maps.event.addListenerOnce(map, \"idle\", () =>\n      doAfterInit(map)\n    );\n  }, [funcs, features_layer]);\n\n  const doAfterInit = (map: google.maps.Map): void => {\n    do_after_init.forEach((cb) => {\n      cb(map);\n    });\n\n    if (initializedCB) {\n      //Tell parent we are initialized if the parent has asked for it.\n      if (!funcs) {\n        throw new Error(\"funcs is undefined\");\n      }\n      initializedCB(map, funcs);\n    }\n  };\n\n  const setupMapEvents = (map: google.maps.Map): void => {\n    map.addListener(\n      \"center_changed\",\n      () => onCenterChanged && onCenterChanged()\n    );\n    map.addListener(\n      \"bounds_changed\",\n      () => onBoundsChanged && onBoundsChanged()\n    );\n    map.addListener(\"click\", (mouse_event) => {\n      if (!funcs) {\n        throw new Error(\"funcs is undefined\");\n      }\n      cutting.enabled && funcs.cuttingClick(mouse_event);\n      onClick && !cutting.enabled && onClick(mouse_event);\n    });\n    map.addListener(\n      \"dblclick\",\n      (mouse_event) =>\n        onDoubleClick && !cutting.enabled && onDoubleClick(mouse_event)\n    );\n    map.addListener(\"drag\", () => onDrag && !cutting.enabled && onDrag());\n    map.addListener(\n      \"dragend\",\n      () => onDragEnd && !cutting.enabled && onDragEnd()\n    );\n    map.addListener(\"dragstart\", () => {\n      do_on_drag_start.forEach((cb) => {\n        if (!cutting.enabled) {\n          cb();\n        }\n      });\n      if (onDragStart && !cutting.enabled) {\n        onDragStart();\n      }\n    });\n    map.addListener(\"heading_changed\", () => {\n      if (onHeadingChanged) {\n        onHeadingChanged();\n      }\n    });\n    map.addListener(\"idle\", () => {\n      do_on_drag_end.forEach((cb) => {\n        if (!cutting.enabled) {\n          cb();\n        }\n      });\n      if (onIdle && !cutting.enabled) {\n        onIdle();\n      }\n    });\n    map.addListener(\"maptypeid_changed\", () => {\n      if (onMapTypeIdChanged) {\n        onMapTypeIdChanged();\n      }\n    });\n    map.addListener(\"mousemove\", (mouse_event: google.maps.MouseEvent) => {\n      if (cutting.enabled) {\n        if (!funcs) {\n          throw new Error(\"funcs is undefined\");\n        }\n        funcs.cuttingPositionUpdate(mouse_event);\n      }\n      if (onMouseMove) {\n        onMouseMove(mouse_event);\n      }\n    });\n    map.addListener(\"mouseout\", (mouse_event: MouseEvent) => {\n      if (onMouseOut) {\n        onMouseOut(mouse_event);\n      }\n    });\n    map.addListener(\"mouseover\", (mouse_event: MouseEvent) => {\n      if (onMouseOver) {\n        onMouseOver(mouse_event);\n      }\n    });\n    map.addListener(\"projection_changed\", () => {\n      if (onProjectionChanged) {\n        onProjectionChanged();\n      }\n    });\n    map.addListener(\"reize\", () => {\n      if (onResize) {\n        onResize();\n      }\n    });\n    map.addListener(\"rightclick\", (mouse_event: MouseEvent) => {\n      if (onRightClick && !cutting.enabled) {\n        onRightClick(mouse_event);\n      }\n    });\n    map.addListener(\"tilesloaded\", () => {\n      if (onTilesLoaded) {\n        onTilesLoaded();\n      }\n    });\n    map.addListener(\"tilt_changed\", () => {\n      if (onTiltChanged) {\n        onTiltChanged();\n      }\n    });\n    map.addListener(\"zoom_changed\", () => {\n      if (onZoomChanged) {\n        onZoomChanged();\n      }\n    });\n  };\n  return (\n    <div style={{ height: \"100%\" }}>\n      <div\n        ref={html_element_ref}\n        style={{\n          position: \"absolute\",\n          top: \"0\",\n          left: \"0\",\n          right: \"0\",\n          bottom: \"0\",\n        }}\n      />\n    </div>\n  );\n};\nexport default WrappedMapBase;\n"]}